#% text_encoding = iso8859_1
##-----------------------------------------------------------------------------------------------
## Web Maps Connector (which shows web maps as layers in Smallworld(TM) Core Spatial Technology)
## Copyright (C) 2017 KUBRA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http:##www.gnu.org/licenses/>.
##
## You may contact KUBRA at https://kubra.com/contact-us/
##-----------------------------------------------------------------------------------------------
b
_package user
$

##
##  Auto-generated by Dialog Designer ( 11/06/2009 )
##
##  System.user_mame = Greg
##

_pragma(classify_level=restricted, topic={wmc_route_finder})
def_slotted_exemplar(:wmc_route_finder_plugin,
	{},
	:plugin)
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder_plugin.init_actions()
	##
	##  Auto-generated by Dialog Designer : 11/06/2009
	##
	##  Initialize actions for SELF.
	##
	_self.add_action(
		sw_action.new(
			:activate_dialog,
			:caption,         _self.message(:caption),
			:short_help_text, _self.message(:short_help_text),
			:engine,          _self,
			:image,           {:wmc_route_finder,_self.module_name},
			:action_message,  :|activate_dialog()|,
			:enabled?,        _self.dataset_open?
			  ) )
_endmethod
$

_pragma(classify_level=restricted)
_method wmc_route_finder_plugin.manage_actions()
	## manages the actions on _self when some status has changed.  

	_self.action(:activate_dialog).enabled? << _self.dataset_open?
	
_endmethod
$

_pragma(classify_level=restricted)
_method wmc_route_finder_plugin.note_change(who, what, _gather data)
	## Watch for change on SOC
	##
	#show(who, what, _scatter data)

	_if (who _is _self.database _orif
	     (who.class_name _is :spatial_object_controller _andif
	      who.name _is _self.database.initial_soc_name)) _andif
	    what _is :view _andif
	    {:added_dsm, :removed_dsm}.includes?(data[1]) _andif
	    data[2].name _is _self.dataset_exemplar.DATASET_NAME
	_then
		_self.action(:activate_dialog).enabled? << data[1] _is :added_dsm
	_endif 
	
_endmethod
$

_pragma(classify_level=advanced)
_method wmc_route_finder_plugin.dataset_open?
	## 
	##
	_return gis_program_manager.cached_dataset(_self.dataset_exemplar.DATASET_NAME) _isnt _unset 
_endmethod
$
_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder_plugin.dataset_exemplar
	## used for the special case of the Geocoding APIs.  Currently
	## returns one of bing_dataset or google_dataset

	_dynamic !current_package!
	
	_return !current_package!.all_packages[:user][(if_ve_acp.geocoding_api_vendor_name + :_dataset).as_symbol()]
_endmethod
$


_pragma(classify_level=advanced)
_method wmc_route_finder_plugin.post_init_plugins()
	## Make self dependent on the SOC 
	##

	_super.post_init_plugins()
	
	_self.database.add_dependent(_self, :view)
	_self.manage_actions()

_endmethod
$


_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder_plugin.build_gui(a_frame,_optional xml_element)
	##
	##  Auto-generated by Dialog Designer : 11/06/2009
	##
	##  Define the GUI layout.
	##
	_local d,a_panel

	d << wmc_route_finder_framework.new(_self.message(:framework_title),_self.framework)

	a_panel << d.build_gui(a_frame,xml_element)
	d.tab_label << _self.message(:tab_title)

	>> a_panel
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder_plugin.activate_dialog(_gather args)
	##
	##  Auto-generated by Dialog Designer : 11/06/2009
	##
	##  Activate & cache the the 'wmc_route_finder' GUI.
	##
	_local d,name

	name << :wmc_route_finder

	_if (d << _self.get_dialog(name)) _is _unset
	_then
		d << wmc_route_finder_framework.new(_self.message(:title),_unset)

		_self.cache_dialog(name,d)
	_endif

	d.maximizable? << _true
	d.minimizable? << _true
	d.resizable?   << _true

	d.activate(_unset,_self.message(name))

	>> d
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
wmc_route_finder_plugin.define_shared_constant(
	:databus_producer_data_types,
	{:post_render_sets,:goto_request},
	:private)
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder_plugin.sw_databus_data_requested(type)
	_if (f << _self.dialogs[:wmc_route_finder]) _isnt _unset
	_then
		diag << f.component(:wmc_route_finder)
		_return diag.sw_databus_data_requested(type)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
wmc_route_finder_plugin.define_shared_constant(
	:databus_consumer_data_types,
	{:active_map_view,:application_coordinate_system,:map_selection,:map_trail},
	:private)
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder_plugin.sw_databus_data_available(type,data)
	_if (f << _self.dialogs[:wmc_route_finder]) _isnt _unset
	_then
		diag << f.component(:wmc_route_finder)
		diag.sw_databus_data_available(type,data)
	_endif
_endmethod
$

# Shortcut to open route finder
_pragma(classify_level=restricted, topic={wmc_route_finder})
_global wmcrf <<
_proc()
	d << wmc_route_finder_plugin.new().activate_dialog()
	
	# Set the databus
	an_app << (_for app _over smallworld_product.applications.fast_elements()
		   _loop
			   _if _not an_app.is_kind_of?( sw:admin_application )
			   _then _leave _with app
			   _endif
		   _endloop)
	_if an_app _isnt _unset
	_then d.databus << an_app.databus
	_endif
	
	>> d
_endproc
$
