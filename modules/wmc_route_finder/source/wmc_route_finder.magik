#% text_encoding = iso8859_1
##-----------------------------------------------------------------------------------------------
## Web Maps Connector (which shows web maps as layers in Smallworld(TM) Core Spatial Technology)
## Copyright (C) 2017 KUBRA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http:##www.gnu.org/licenses/>.
##
## You may contact KUBRA at https://kubra.com/contact-us/
##-----------------------------------------------------------------------------------------------

_package user
$

########################################################################
##
## Last Saved Time-stamp:
##
## Created By: Greg Cahill, iFactor Consulting
## Date: 06-Nov-2009
##
##  Auto-generated by Dialog Designer ( 11/06/2009 )
##
## Description: The WMC Route Finder allows the user to enter
## waypoints and calculates the route between them by issuing a
## request to the appropriate maps server API.
##
## ---------- Revision History -----------
##
## -------- end revision history ---------
########################################################################

_pragma(classify_level=restricted, topic={wmc_route_finder})
def_slotted_exemplar(:wmc_route_finder,
	{
		{:items, _unset, :writable},
		{:waypoints, _unset, :writable},
		{:current_waypoint, _unset, :writable},
		{:route_results, _unset, :writable},
		{:thread, _unset, :writable}
	},
	:plugin)
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
wmc_route_finder.define_shared_constant(
	:databus_producer_data_types,
	{:post_render_sets, :goto_request, :set_map_trail,
	:geometry_to_draw, :geometry_to_undraw,
	:geometry_to_highlight, :geometry_to_unhighlight},
	_false)
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
wmc_route_finder.define_shared_constant(
	:databus_consumer_data_types,
	{:active_map_view, :application_coordinate_system, :map_selection, :map_trail},
	_false)
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
wmc_route_finder.define_shared_variable(
	:style_for_route,
	line_style.new_with_properties(
		:foreground_colour, colour.called(:fuchsia),
		:dash_pattern, dash_pattern.chain_dash,
		:width, 8),
	:public)
$
_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.safe_current_coordinate_system()
	## if there is no !current_coordinate_system! set, then use one
	## customized for the current installation.

	_import _dynamic !current_coordinate_system!

	_if !current_coordinate_system! _is _unset 
	_then
		!current_coordinate_system! << wmc_dataset_manager.custom_coordinate_system()
	_endif
_endmethod
$

_pragma(classify_level=restricted,usage={subclassable})
_private _method wmc_route_finder.init( name, a_framework, _optional properties )
	## Initialises slots and dependencies.
	##

	.waypoints << wmc_waypoint_list.new()
	.route_results << hash_table.new()

	# Set the databus
	_self.get_databus()

	# Make sure the VE SOM exists
	_self.open_dataset()
	#_self.manage_vhs_settings()
	
	>> _super.init(name, a_framework, properties)
	
_endmethod
$
_pragma(classify_level=restricted,usage={subclassable})
_method wmc_route_finder.application
	## returns an application for self.

	_for app _over smallworld_product.applications.fast_elements()
	_loop
		_if _not app.is_kind_of?( sw:admin_application )
		_then
			_return app
		_endif
	_endloop

	_return _unset 
_endmethod
$


_pragma(classify_level=restricted,usage={subclassable})
_method wmc_route_finder.get_databus()
	## Returns self's databus
	##

	an_app << _self.application
	
	_if an_app _isnt _unset
	_then
		_self.databus << an_app.databus
	_endif

	>> _self.databus
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.init_actions()
	##
	##  Auto-generated by Dialog Designer : 11/06/2009
	##
	##  Initialize actions for SELF.
	##

	#
	# Work Area Actions ...
	#
	_self.add_action( sw_action.new( :add_selected,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:add_selected),
		:engine,                 _self,
		:action_message,         {:|add_waypts()|, :selection, :last},
		:image,                 {:add_to_selection,:ui_resources} ) )

	_self.add_action( sw_action.new( :add_trail_pts,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:add_trail_pts),
		:engine,                 _self,
		:action_message,         {:|add_waypts()|, :trail, :last},
		:image,                 {:add_trail_to_area,:geometry_editors} ) )

	_self.add_action( sw_action.new( :reverse_waypts,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:reverse_waypts),
		:engine,                 _self,
		:action_message,         :|reverse_waypts()|,
		:image,                 {:reverse_trail,:map_trail} ) )
		#:image,                 {:reverse,_self.module_name} ) )

	_self.add_action( sw_action.new( :sort_waypts,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:sort_waypts),
		:engine,                 _self,
		:action_message,         {:|sort_waypts()|, :salesman},
		:image,                 {:sort_a_z,:ui_resources} ) )

	_self.add_action( sw_action.new( :roundtrip_waypts,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:roundtrip_waypts),
		:engine,                 _self,
		:action_message,         :|roundtrip_waypts()|,
		:image,                 {:roundtrip,_self.module_name} ) )

	_self.add_action( sw_action.new( :clear_waypts,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:clear_waypts),
		:engine,                 _self,
		:action_message,         :|clear_waypts()|,
		:image,                 {:clear,:ui_resources} ) )

	_self.add_action( sw_action.new( :save_waypts,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:save_waypts),
		:engine,                 _self,
		:action_message,         :|save_waypts()|,
		:image,                 {:save,_self.module_name} ) )

	_self.add_action( sw_action.new( :load_waypts,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:load_waypts),
		:engine,                 _self,
		:action_message,         :|load_waypts()|,
		:image,                 {:open,_self.module_name} ) )

	_self.add_action( sw_action.new( :goto_waypt,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:goto_waypt),
		:engine,                 _self,
		:action_message,         {:|go_to_waypt()|, _false},
		:image,                 {:goto_object,:ui_resources} ) )

	_self.add_action( sw_action.new( :add_before,
		:toolbar_control,        :button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:add_before),
		:engine,                 _self,
		:action_message,         {:|add_waypts()|, :both, :before} ))

	_self.add_action( sw_action.new( :add_after,
		:toolbar_control,        :button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:add_after),
		:engine,                 _self,
		:action_message,         {:|add_waypts()|, :both, :after} ))

	_self.add_action( sw_action.new( :flash_waypt,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:flash_waypt),
		:engine,                 _self,
		:action_message,         :|flash_waypt()|,
		:image,                 {:new,:ui_resources} ) )

	_self.add_action( sw_action.new( :move_waypt_top,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:move_waypt_top),
		:engine,                 _self,
		:action_message,         {:move_waypts|()|, :top},
		:image,                 {:top,:ui_resources} ) )

	_self.add_action( sw_action.new( :move_waypt_up,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:move_waypt_up),
		:engine,                 _self,
		:action_message,         {:move_waypts|()|, :up},
		:image,                 {:up,:ui_resources} ) )

	_self.add_action( sw_action.new( :remove_waypt,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:remove_waypt),
		:engine,                 _self,
		:action_message,         :|remove_waypt()|,
		:image,                 {:delete,:ui_resources} ) )

	_self.add_action( sw_action.new( :move_waypt_down,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:move_waypt_down),
		:engine,                 _self,
		:action_message,         {:move_waypts|()|, :down},
		:image,                 {:down,:ui_resources} ) )

	_self.add_action( sw_action.new( :move_waypt_bottom,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:move_waypt_bottom),
		:engine,                 _self,
		:action_message,         {:move_waypts|()|, :bottom},
		:image,                 {:bottom,:ui_resources} ) )

	_self.add_action( sw_action.new( :calculate_route,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:calculate_route),
		:engine,                 _self,
		:action_message,         :|calculate_route()|,
		:image,                 {:run,_self.module_name} ) )

	_self.add_action( sw_action.new( :zoom_to_route,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:zoom_to_route),
		:engine,                 _self,
		:action_message,         :|zoom_to_route()|,
		:image,                 {:zoom_to_selection,:ui_resources} ) )

	_self.add_action( sw_action.new( :set_trail_from_route,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:set_trail_from_route),
		:engine,                 _self,
		:action_message,         :|set_trail_from_route()|,
		:image,                 {:set_trail_to_selection,:map_trail} ) )

	_self.add_action( sw_action.new( :save_results,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:save_results),
		:engine,                 _self,
		:action_message,         :|save_results()|,
		:image,                 {:save,_self.module_name} ) )

	_self.add_action( sw_action.new( :clear_results,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:clear_results),
		:engine,                 _self,
		:action_message,         :|clear_results()|,
		:image,                 {:clear,:ui_resources} ) )

	_self.add_action( sw_action.new( :goto_direction,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:goto_direction),
		:engine,                 _self,
		:action_message,         :|goto_direction()|,
		:image,                 {:goto_object,:ui_resources} ) )

	_self.add_action( sw_action.new( :flash_direction,
		:toolbar_control,        :image_button_item,
		:menubar_control,        :button_item,
		:caption,                _self.message(:flash_direction),
		:engine,                 _self,
		:action_message,         :|flash_direction()|,
		:image,                 {:new,:ui_resources} ) )

	_self.add_action( sw_action.new( :distance_units,
		:menubar_control,        :radio_set,
		:dialog_control,         :radio_set,
		:caption,                _self.message(:distance_units),
		:engine,                 _self,
		:value,                  :mile,
		:value_change_message, :toggle_distance_units|()|,
		:actions, {
				  sw_action.new(:mile_units,
						:caption, _self.message(:mile),
						:value, :mile),
				  sw_action.new(:km_units,
						:caption, _self.message(:km),
						:value, :km)
		}
		))

	_self.add_action(sw_action.new(:show_waypt_in_web_browser,
				       :engine,          _self,
				       :action_message,  {:|show_in_web_browser()|,:waypt} ,
				       :toolbar_control, :image_button_item ,
				       :caption,         _self.message(:show_in_web_browser  ),
				       :short_help_text, _self.message(:show_in_web_browser_sh  ),
				       :tooltip,         _self.message(:show_in_web_browser_tt),
				       :image,           {:web_browser, _self.module_name}    )
	      )

	_self.add_action(sw_action.new(:show_waypt_birds_eye_in_web_browser,
				       :engine,          _self,
				       :action_message,  {:|show_in_web_browser()|,:waypt, :birdseye} ,
				       :toolbar_control, :image_button_item ,
				       :caption,         _self.message(:show_birds_eye_in_web_browser  ),
				       :short_help_text, _self.message(:show_birds_eye_in_web_browser_sh  ),
				       :tooltip,         _self.message(:show_birds_eye_in_web_browser_tt),
				       :image,           {:birds_eye, _self.module_name}  )
	      )

	_self.add_action(sw_action.new(:show_dir_in_web_browser,
				       :engine,          _self,
				       :action_message,  {:|show_in_web_browser()|,:route} ,
				       :toolbar_control, :image_button_item ,
				       :caption,         _self.message(:show_in_web_browser  ),
				       :short_help_text, _self.message(:show_in_web_browser_sh  ),
				       :tooltip,         _self.message(:show_in_web_browser_tt),
				       :image,           {:web_browser, _self.module_name}    )
	      )

	_self.add_action(sw_action.new(:show_dir_birds_eye_in_web_browser,
				       :engine,          _self,
				       :action_message,  {:|show_in_web_browser()|,:route,:birdseye} ,
				       :toolbar_control, :image_button_item ,
				       :caption,         _self.message(:show_birds_eye_in_web_browser  ),
				       :short_help_text, _self.message(:show_birds_eye_in_web_browser_sh  ),
				       :tooltip,         _self.message(:show_birds_eye_in_web_browser_tt),
				       :image,           {:birds_eye, _self.module_name}  )
	      )

	# Options
	# Route Style
	_self.add_action(sw_action.new( :route_style_color,
					:caption, "",
					:image, { :line_colour_dynamic, :style_widgets },
					:tooltip, _self.message(:route_style_color),
					:engine, _self,
					:value, _self.style_for_route.colour,
					:value_change_message, { :set_route_style|()|, :line_fg_colour },
					:dialog_control, { :colour_choice_item,
							   :allow_no_value?, _false ,
							   :allow_custom_colours?, _true },
					:toolbar_control, { :colour_choice_button_item,
							    :allow_no_value?, _true }
				   ) )
	_self.add_action(sw_action.new( :route_style_width,
					:caption, "",
					:image, { :line_width_dynamic, :style_widgets },
					:tooltip, _self.message(:route_style_width),
					:engine, _self,
					:value, _self.style_for_route.width,
					:value_change_message, { :set_route_style|()|, :line_width },
					:dialog_control, { :line_width_choice_item,
							   :allow_mm_widths?, _true},

					:toolbar_control, { :line_width_choice_button_item }
				   ) )
	
	_self.add_action(sw_action.new( :route_style_dash,
					:caption, "",
					:image, { :dash_pattern_dynamic, :style_widgets },
					:tooltip, _self.message(:route_style_dash),
					:engine, _self,
					:value, _self.style_for_route.dash_style,
					:value_change_message, { :set_route_style|()|, :dash_pattern },
					:dialog_control, { :dash_pattern_choice_item},

					:toolbar_control, { :dash_pattern_choice_button_item }
				) )

	# Waypoint Style
	_self.add_action(sw_action.new( :show_waypoint_labels,
					:caption, _self.message(:show_waypoint_labels),
					:engine, _self,
					:value, _true,
					:value_change_message, :set_wp_style|()|,
					:toolbar_control, :toggle_item
				   ) )
	
	_self.add_action(sw_action.new( :wp_style_color,
					:caption, "",
					:image, { :line_colour_dynamic, :style_widgets },
					:tooltip, _self.message(:wp_style_color),
					:engine, _self,
					:value, colour.called(:limegreen),
					:value_change_message, :set_wp_style|()|,
					:dialog_control, { :colour_choice_item,
							   :allow_no_value?, _false ,
							   :allow_custom_colours?, _true },
					:toolbar_control, { :colour_choice_button_item,
							    :allow_no_value?, _true }
				   ) )

	#
	# Menubar Actions ...
	#
	_self.add_action( sw_action.new( :quit,
		:menubar_control,        :button_item,
		:engine,                 _self,
		:action_message,         :|quit()| ) )

	_self.add_action( sw_action.new( :about,
		:menubar_control,        :button_item,
		:engine,                 _self,
		:action_message,         :about|()| ) )
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.sw_databus_data_requested(type, _gather args)
	## Add interesting geometries to the post-render sets
	##

	_if type _is :post_render_sets
	_then
		_return _self.post_render_geometries(_scatter args)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.post_render_geometries(_gather args)
	## Return waypoints and route results for map post-rendering.
	##

	_self.safe_current_coordinate_system()
	
	a_rope << rope.new()

	# The route first, so waypoints draw on top.
	_if _not (a_gs << _self.route_geometries()).empty?
	_then
		a_rope.add(a_gs)
	_endif
	
	# The waypoints
	_if _self.action(:show_waypoint_labels).value _andif 
	    _not (gs_sets << _self.waypoint_geometries()).empty?
	_then
		a_rope.add_last(gs_sets)
	_endif

	_return composite_geometry_set.new(a_rope)

_endmethod
$
	
_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.waypoint_geometries()
	## Return waypoints as a geometry set.
	##

	_self.safe_current_coordinate_system()
	
	a_colour << _self.action(:wp_style_color).value
	a_pin_gs << geometry_set.new()
	_for a_key, a_wp _over .waypoints.fast_keys_and_elements()
	_loop
		a_pt << pseudo_point.new(a_wp.location, 0.0)
		a_pt.style_info << a_wp.point_style(a_key.write_string, a_colour)
		a_pin_gs.add(a_pt)
	_endloop

	_return a_pin_gs
		
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.route_geometries()
	## Return route as a geometry set.
	##
	_self.safe_current_coordinate_system()
	
	a_gs << geometry_set.new()
	_if (a_rt << .route_results[:route_path]) _isnt _unset
	_then
		a_gs << geometry_set.new()
		a_gs.add(a_rt)
	_endif

	_return a_gs
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.sw_databus_data_available(type,data)
	##
	##

	waypt_sel? << _not .waypoints.empty? _andif 
		      _not .items[:waypt_list].selection.empty?
	_if type _is :map_selection
	_then
		_self.action(:add_selected).enabled? << _not data[2].empty?
		_self.action(:add_before).enabled? <<
			_self.action(:add_after).enabled? << waypt_sel? _andif
							     _not data[2].empty?
	_elif type _is :map_trail
	_then 
		_self.action(:add_trail_pts).enabled? << data[2].geometry _isnt _unset
		_self.action(:add_before).enabled? <<
			_self.action(:add_after).enabled? << waypt_sel? _andif
							     data[2].geometry _isnt _unset
	_endif

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.manage_actions()
	# ~~ needs code review ~~
	## Manage self's actions
	##

	waypts? << _not .waypoints.empty?
	more_than_1? << .waypoints.size > 1
	
	# B.Clark iFactor Consulting 12/16/2010
	# Sorting makes sense for more than two waypoints
	more_than_2? << .waypoints.size > 2
	# End change - 12/16/2010
	
	selected? << _not .items[:waypt_list].selection.empty?
	waypt_sel? << waypts? _andif selected?
	a_bus << _self.get_databus()
	map_sel? << a_bus _isnt _unset _andif 
		    (a_sel << a_bus.request_data(:map_selection)) _isnt _unset _andif
		    _not a_sel.empty? _andif _not a_sel[2].empty?
	map_trail? << a_bus _isnt _unset _andif 
		      (map_trail << a_bus.request_data(:map_trail)) _isnt _unset _andif
		      _not map_trail.empty? _andif map_trail[2].geometry _isnt _unset

	_self.action(:add_selected).enabled? << map_sel?
	_self.action(:add_trail_pts).enabled? << map_trail?

	_self.action(:clear_waypts).enabled? << 
		_self.action(:save_waypts).enabled? <<
		waypts?

	# B.Clark iFactor Consulting 12/16/2010
	# Sorting makes sense for more than two waypoints
	_self.action(:reverse_waypts).enabled? <<
		#_self.action(:sort_waypts).enabled? <<
		_self.action(:roundtrip_waypts).enabled? <<
		more_than_1?

	_self.action(:sort_waypts).enabled? <<	more_than_2?
	# End change - 12/16/2010	
	
	_self.action(:goto_waypt).enabled? <<
		_self.action(:flash_waypt).enabled? <<
		_self.action(:show_waypt_in_web_browser).enabled? <<
		_self.action(:show_waypt_birds_eye_in_web_browser).enabled? <<
		waypt_sel?

	_self.action(:add_before).enabled? <<
		_self.action(:add_after).enabled? <<
		waypt_sel? _and (map_sel? _or map_trail?)

	running? << .thread _isnt _unset _andif .thread.vm_status _is .thread.status_running
	_self.action(:calculate_route).enabled? << more_than_1? _and _not running?

	_self.action(:remove_waypt).enabled? << selected?
	_self.action(:move_waypt_top).enabled? << 
		_self.action(:move_waypt_up).enabled? << 
		_self.action(:move_waypt_down).enabled? << 
		_self.action(:move_waypt_bottom).enabled? << 
		more_than_1? _and selected?

	route? << _not _self.route_results.empty?
	dir? << _if _not route?
		_then >> _false
		_else
			>> _for a_res _over .items[:route_results].selection.fast_elements()
			_loop
				_if (a_item << a_res.value) _isnt _unset _andif
				    a_item.is_kind_of?(wmc_route_item)
				_then
					_leave _with _true 
				_endif
			_finally
				_leave _with _false
			_endloop
		_endif
	
	_self.action(:zoom_to_route).enabled? << 
		_self.action(:set_trail_from_route).enabled? << 
		_self.action(:save_results).enabled? << 
		_self.action(:clear_results).enabled? <<
		route?
	_self.action(:goto_direction).enabled? << 
		_self.action(:flash_direction).enabled? << 
		_self.action(:show_dir_in_web_browser).enabled? << 
		_self.action(:show_dir_birds_eye_in_web_browser).enabled? << 
		dir?
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.build_gui(a_frame,_optional xml_element)
	##
	##  Auto-generated by Dialog Designer : 11/06/2009
	##
	##  Define the GUI layout.
	##

	.items << property_list.new()

	rowcol_01 << rowcol.new(a_frame,1,1,:pixel,
		:resize?,	_true,
		:tab_label,	_self.message(:title),
		:bottom_spacing,	6,
		:col_spacing,	7,
		:default_col_alignment,	:fill,
		:default_row_alignment,	:fill,
		:left_spacing,	6,
		:right_spacing,	6,
		:row_spacing,	6,
		:top_spacing,	6)

	a_tab_box << tab_box.new(rowcol_01,
			       :resize?,_true,
			       :row,1,:col,1,
			       :row_alignment,:fill,:col_alignment,:fill)
	
	_self.build_main_tab(a_tab_box)
	_self.build_options_tab(a_tab_box)
	
	_self.manage_actions()
	
	>> rowcol_01
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.build_main_tab(a_tab_box)
	## Build the waypoints and route tab
	##

	pw << paned_window.new(a_tab_box,
			       :tab_label,	_self.message(:main),
			       :side_by_side?, _false,
			       :row_resize_values,	{15,85})
	
	#rowcol_03 << rowcol.new(rowcol_01,3,1,:pixel,
	rowcol_03 << rowcol.new(pw,3,1,:pixel,
		:style, :top_level,
		:min_height, 40,
		:resize?,	_true,
		:tab_label,	_self.message(:title),
		:bottom_spacing,	0,
		#:col,	1,
		:col_spacing,	7,
		#:col_alignment,	:fill,
		#:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		#:row,	1,
		:row_resize_values,	{0,0,100},
		:row_spacing,	6,
		:top_spacing,	0)

	rowcol_05 << rowcol.new(rowcol_03,1,_unset,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:col,	1,
		:col_spacing,	2,
		:col_alignment,	:fill,
		:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:row,	2,
		:row_spacing,	6,
		:top_spacing,	0)

	rowcol_07 << rowcol.new(rowcol_03,1,2,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:col,	1,
		:col_resize_values,	{100,0},
		:col_spacing,	2,
		:col_alignment,	:fill,
		:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:row,	3,
		:row_spacing,	6,
		:top_spacing,	0)

	.items[:waypts_label] << label_item.new(rowcol_05,_self.message(:waypts_label),
			:col,	1,
			:col_alignment,	:fill,
			:row,	1,
			:row_alignment,	:top)

	wp_tb << toolbar.new(rowcol_05)
	wp_tb.border? << _true
	_self.action(:add_selected).place_control_on(wp_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	1,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})
	
	_self.action(:add_trail_pts).place_control_on(wp_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	2,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	wp_tb2 << toolbar.new(rowcol_05)
	wp_tb2.border? << _true
	
	_self.action(:reverse_waypts).place_control_on(wp_tb2,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	4,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:sort_waypts).place_control_on(wp_tb2,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	5,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:roundtrip_waypts).place_control_on(wp_tb2,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	5,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:clear_waypts).place_control_on(wp_tb2,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	6,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:save_waypts).place_control_on(wp_tb2,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	7,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:load_waypts).place_control_on(wp_tb2,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	8,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	wp_tb3 << toolbar.new(rowcol_05)
	wp_tb3.border? << _true
	_self.action(:calculate_route).place_control_on(wp_tb3,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	1,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	rowcol_09 << rowcol.new(rowcol_07,1,1,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:col,	1,
		:col_spacing,	7,
		:col_alignment,	:fill,
		:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:row,	1,
		:row_spacing,	6,
		:top_spacing,	0)

	rowcol_08 << rowcol.new(rowcol_07,_unset,1,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:col,	2,
		:col_spacing,	0,
		:col_alignment,	:right,
		:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:row,	1,
		:row_spacing,	2,
		:top_spacing,	0)

	.items[:waypt_list] << wps << tree_item.new(rowcol_09,
		:model,	_self,
		:aspect, :|waypt_list|,
		:select_notifier,	:|waypt_selected()|,
		:double_click_notifier,	:|go_to_waypt()|,
		:height,	120,
		:mode,	:many,
		#:column_heading_ids, {:waypt_flag, :waypt_name, :birds_eye_view},
		#:col_resize_values, {0, 1, 0},
		#:column_selectabilities, {_false, _false, _true},
		:col,	1,
		:col_alignment,	:fill,
		:row,	1,
		:row_alignment,	:fill)
	a_menu << wps.create_default_popup_menu(_true)
	separator_item.new(a_menu)
	_self.action(:add_before).place_control_on(a_menu,:menu)
	_self.action(:add_after).place_control_on(a_menu,:menu)
	_self.action(:flash_waypt).place_control_on(a_menu,:menu)
	_self.action(:goto_waypt).place_control_on(a_menu,:menu)
	_self.action(:show_waypt_in_web_browser).place_control_on(a_menu,:menu)
	_self.action(:show_waypt_birds_eye_in_web_browser).place_control_on(a_menu,:menu)
	wps.popup_menu << a_menu


	move_tb << toolbar.new(rowcol_08)
	move_tb.border? << _true
	move_tb.vertical? << _true
	_self.action(:move_waypt_top).place_control_on(move_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	1,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:move_waypt_up).place_control_on(move_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	1,
			:col_alignment,	:left,
			:row,	2,
			:row_alignment,	:top})

	_self.action(:remove_waypt).place_control_on(move_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	1,
			:col_alignment,	:left,
			:row,	3,
			:row_alignment,	:top})

	_self.action(:move_waypt_down).place_control_on(move_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	1,
			:col_alignment,	:left,
			:row,	4,
			:row_alignment,	:top})

	_self.action(:move_waypt_bottom).place_control_on(move_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	1,
			:col_alignment,	:left,
			:row,	5,
			:row_alignment,	:top})

	#rowcol_04 << rowcol.new(rowcol_01,3,1,:pixel,
	rowcol_04 << rowcol.new(pw,3,1,:pixel,
		:style, :top_level,
		:min_height, 40,
		:resize?,	_true,
		:bottom_spacing,	0,
		#:col,	1,
		:col_spacing,	7,
		#:col_alignment,	:fill,
		#:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		#:row,	2,
		:row_resize_values,	{0,0,100},
		:row_spacing,	6,
		:top_spacing,	0)

	rowcol_06 << rowcol.new(rowcol_04,1,_unset,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:col,	1,
		:col_spacing,	7,
		:col_alignment,	:fill,
		:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:row,	2,
		:row_spacing,	6,
		:top_spacing,	0)

	rowcol_02 << rowcol.new(rowcol_04,1,1,:pixel,
		:resize?,	_true,
		:bottom_spacing,	0,
		:col,	1,
		:col_spacing,	7,
		:col_alignment,	:fill,
		:row_alignment,	:fill,
		:left_spacing,	0,
		:right_spacing,	0,
		:row,	3,
		:row_spacing,	6,
		:top_spacing,	0)

	.items[:results_label] << label_item.new(rowcol_06,_self.message(:results_label),
			:col,	1,
			:col_alignment,	:fill,
			:row,	1,
			:row_alignment,	:top)

	res_tb << toolbar.new(rowcol_06)
	res_tb.border? << _true

	_self.action(:zoom_to_route).place_control_on(res_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	2,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:set_trail_from_route).place_control_on(res_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	3,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:save_results).place_control_on(res_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	4,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	_self.action(:clear_results).place_control_on(res_tb,:toolbar,
		:has_border?, _false,
		:control_type, { :image_button_item,
			:col,	5,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	res_tb2 << toolbar.new(rowcol_06)
	res_tb2.border? << _true
	res_tb2.min_height << res_tb.height

	_self.action(:distance_units).place_control_on(res_tb2,:toolbar,
		:has_border?, _false,
		:control_type, { :radio_set,
			:col,	1,
			:col_alignment,	:left,
			:row,	1,
			:row_alignment,	:top})

	.items[:route_results] << res << tree_item.new(rowcol_02,
		:model,	_self,
		:aspect,	:|route_results_list|,
		:col,	1,
		:col_alignment,	:fill,
		:double_click_notifier,	:|goto_direction()|,
		:height,	120,
		:mode,	:many,
		:row,	1,
		:row_alignment,	:fill,
		:select_notifier,	:|route_results_selected()|,
		:right_click_notifier,  :|route_result_right_click()|,
		:width,	400 )
	a_menu << res.create_default_popup_menu(_true)
	separator_item.new(a_menu)
	#_self.action(:flash_direction).place_control_on(a_menu,:menu)
	_self.action(:goto_direction).place_control_on(a_menu,:menu)
	_self.action(:show_dir_in_web_browser).place_control_on(a_menu,:menu)
	_self.action(:show_dir_birds_eye_in_web_browser).place_control_on(a_menu,:menu)
	res.popup_menu << a_menu

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.build_options_tab(a_tab_box)
	## Build the GUI for the options tabe
	##
	
	rowcol_01 << rowcol.new(a_tab_box,2,1,:pixel,
		:resize?,	_true,
		:tab_label,	_self.message(:options),
		#:default_col_alignment,	:fill,
		#:default_row_alignment,	:fill,
		:bottom_spacing,	0,
		:col_spacing,	7,
		:left_spacing,	0,
		:right_spacing,	0,
		:row_spacing,	6,
		:top_spacing,	0)

	gb << group_box.new(rowcol_01,_self.message(:route_style),
		:col_alignment,	:fill,
		:row_alignment,	:top,
		:row,1,:col,1)
	group_box_01 << rowcol.new(gb,1,3,:pixel,
		:resize?,	_true,
		:bottom_spacing,	-10,
		:col_spacing,	7,
		:left_spacing,	5,
		:right_spacing,	5,
		:row_spacing,	6,
		:top_spacing,	5)

	_self.action(:route_style_color).place_control_on(group_box_01,:dialog,
		:control_type, { :colour_choice_item,
			:width, 50,
			:col,	1,
			:row,	1,
			:row_alignment,	:top } )

	_self.action(:route_style_width).place_control_on(group_box_01,:dialog,
		:control_type, { :line_width_choice_item,
			:width, 50,
			:col,	2,
			:row,	1,
			:row_alignment,	:top } )

	_self.action(:route_style_dash).place_control_on(group_box_01,:dialog,
		:control_type, { :dash_pattern_choice_item,
			:width, 50,
			:col,	3,
			:row,	1,
			:row_alignment,	:top } )

	gb2 << group_box.new(rowcol_01,_self.message(:wp_style),
		:col_alignment,	:fill,
		:row_alignment,	:top,
		:row,2,:col,1)

	group_box_02 << rowcol.new(gb2,1,3,:pixel,
		:resize?,	_true,
		:bottom_spacing,	-10,
		:col_spacing,	7,
		:left_spacing,	5,
		:right_spacing,	5,
		:row_spacing,	6,
		:top_spacing,	5)

	_self.action(:show_waypoint_labels).place_control_on(group_box_02,:dialog,
		:control_type, {:toggle_item,
				:col, 1, :row, 1}
					    )

	_self.action(:wp_style_color).place_control_on(group_box_02,:dialog,
		:control_type, { :colour_choice_item,
			:width, 50,
			:col,	2,
			:row,	1,
			:row_alignment,	:top } )
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.toggle_distance_units()
	##

	# Refresh the results list with the new units.
	_self.changed(:route_results_list, :renew)

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.quit()
	##  Close the dialog.
	##

	_if .thread _isnt _unset _andif
	    .thread.vm_status _is .thread.status_running
	_then
		.thread.kill()
	_endif
	
	.framework.close()
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.about(_gather args)
	##
	##  Auto-generated by Dialog Designer : 11/06/2009

	_self.dd_default_method("wmc_route_finder.about()",_scatter args)
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.waypt_list
	##
	##
	_self.safe_current_coordinate_system()
	
	a_rope << .waypoints.as_display_trees()

	# Reselect current waypoint
	_if .current_waypoint _isnt _unset
	_then
		_for a_dt _over a_rope.fast_elements()
		_loop
			_for a_wp _over .current_waypoint.fast_elements()
			_loop 
				a_dt.selected? << (a_dt.value[:name] = a_wp.value[:name])
			_endloop
		_endloop 
	_endif

	>> a_rope
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.waypt_selected(a_sel)
	##
	##
	_self.safe_current_coordinate_system()
	
	.current_waypoint << a_sel
	_self.manage_actions()
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.go_to_waypt(_optional new_window?, args)
	##
	##
	_self.safe_current_coordinate_system()
	
	_if .current_waypoint _isnt _unset _andif
	    _not .current_waypoint.empty?
	_then
		a_gs << geometry_set.new()
		_for a_wp _over .current_waypoint.fast_elements()
		_loop
			a_gs.add(a_wp.value[:location])
		_endloop 
		_self.databus.make_data_available(:goto_request, {a_gs.bounds,
								  :new_window?, new_window?.default(_true),
								  :highlight?, _true})
	_endif

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.flash_waypt()
	## Draws and undraws the designated waypoint in rapid
	## succession, simulating a flash.
	# From MBuller

	_self.safe_current_coordinate_system()
	
	a_colour << _self.action(:wp_style_color).value
	a_gs << geometry_set.new()
	_if .current_waypoint _isnt _unset _andif
	    _not .current_waypoint.empty?
	_then
		ind << 0
		_for a_item _over .items[:waypt_list].tree_manager.fast_trees()
		_loop
			ind+<<1
			_if a_item.selected?
			_then
				a_pt << pseudo_point.new(a_item.value[:location], 0.0)
				a_pt.style_info << wmc_waypoint.point_style(ind.write_string, a_colour)
				a_gs.add(a_pt)
			_endif 
		_endloop 
	_endif

	_if _not a_gs.empty?
	_then
		a_view << _self.databus.request_data(:active_map_view)
		_proc(a_gs, a_db, a_view)
			_for i _over range(1,5)
			_loop
				# FIXME - these databus messages are not working
				#a_db.make_data_available(:geometry_to_undraw, a_gs, _self)
				#a_db.make_data_available(:geometry_to_highlight, a_gs)
				a_view.draw_geometry(a_gs, a_view.application.highlight_colour)
				_thisthread.sleep(200)
				#a_db.make_data_available(:geometry_to_draw, a_gs, _self)
				#a_db.make_data_available(:geometry_to_unhighlight, a_gs)
				a_view.draw_geometry(a_gs)
				_thisthread.sleep(200)
			_endloop
		_endproc.fork_at(_thisthread.background_priority, a_gs, _self.databus, a_view)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.add_waypts(selection_or_trail, position, _gather args)
	## Add selection or trail to list of waypoints
	##

	_self.safe_current_coordinate_system()

	a_pos << position
	_if {:before, :after}.includes?(a_pos)
	_then
		# Find the (first) selected waypoint
		ind << (_if a_pos _is :before
			_then >> 0
			_else >> 1
			_endif)
		a_pos << (_for a_item _over .items[:waypt_list].tree_manager.fast_trees()
			  _loop
				  ind+<<1
				  _if a_item.selected?
				  _then _leave _with ind
				  _endif
			  _finally
				  _leave _with :last
			  _endloop)
	_endif

	added? << _false
	_if {:both, :selection}.includes?(selection_or_trail)
	_then
		added? << _self.add_selected(a_pos)
	_endif
	_if {:both, :trail}.includes?(selection_or_trail)
	_then
		added? _or<< _self.add_trail_pts(a_pos)
	_endif

	_if added?
	_then 
		_self.changed(:waypt_list, :refresh)
		_self.manage_actions()

		# Get the reverse-geocode description for the waypoints.
		_self.get_waypt_descriptions(_true)

		_if _self.using_google?
		_then
			_local a_bus, a_view

			google_rwo_record.route_finder_info[:wmc_route_finder] << _self
			
			_if (a_bus << _self.get_databus()) _isnt _unset _andif
			    (a_view << a_bus.request_data(:active_map_view)) _isnt unset
			_then
				#a_view.render()
			_endif
		_endif 
	_endif
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.add_selected(position)
	## Add selected RWOs to list of waypoints
	##

	added? << _false
	
	# Set the databus
	_if (a_bus << _self.get_databus()) _isnt _unset _andif
	    (map_sel << a_bus.request_data(:map_selection)) _isnt _unset
	_then
		# List waypoints
		_for a_geom _over map_sel[2].fast_elements()
		_loop
			.waypoints.add_geom(a_geom, position)
			added? << _true
		_endloop
	_endif

	_return added?

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.add_trail_pts(position)
	## Add locations from trail points as waypoints
	##

	added? << _false
	
	# Set the databus
	_if (a_bus << _self.get_databus()) _isnt _unset _andif
	    (map_trail << a_bus.request_data(:map_trail)) _isnt _unset _andif 
	    map_trail[2].geometry _isnt _unset
	_then
		# List waypoints
		_for a_sec _over map_trail[2].geometry.fast_elements()
		_loop
			_for a_coord _over a_sec.fast_elements()
			_loop
				.waypoints.add_coord(a_coord, map_trail[2].world, position)
				added? << _true
			_endloop 
		_endloop
	_endif
	
	_return added?
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.get_waypt_descriptions(_optional append?)
	## Loop over the waypoints to get their descriptions.  This
	## will usually be a reverse-geocoded addresss.
	## append? is true if the new description should be appended to
	## the existing.  Else it will be replaced.

	_self.safe_current_coordinate_system()
	
	append? << append?.default(_false)
	
	# Put this in threads because it may take some time
	# Can handle only 10 threads, so divide the work
	max_threads << 1.0  # Using more threads does not improve performance!
	n_per_thread << (.waypoints.size/max_threads).ceiling

	_local me << _self
	desc_proc << _proc(wps, append?)
			     _import me
			     #st << system.elapsed_seconds()
			     a_strm << internal_text_output_stream.new()
			     _for a_wp _over wps.fast_elements()
			     _loop
				     # Already geocoded?
				     _if a_wp.description.includes?(%@) _then _continue _endif

				     a_desc << a_wp.location.coordinate.description_for_route_finder()
				     _if append? _andif 
					 _not a_wp.description.matches?("coordinate:*")
				     _then
					     a_strm.write(a_wp.description)
					     _if _not a_desc.matches?("coordinate:*")
					     _then a_strm.write(" @ ", a_desc)
					     _endif
				     _else
					     # Could be geocoded?
					     _if _not a_desc.matches?("coordinate:*")
					     _then a_strm.write("@ ")
					     _endif
					     a_strm.write(a_desc)
				     _endif
				     a_wp.description << a_strm.string
				     a_strm.reset()
				     me.changed(:waypt_list, :renew)
			     _endloop
			     #write(wps, tab_char, wps[1].location.coord, " done: ", system.elapsed_seconds()-st)
		     _endproc
	
	a_rope << rope.new()
	_for a_wp _over .waypoints.fast_elements()
	_loop
		a_rope.add(a_wp)
		_if a_rope.size >= n_per_thread
		_then
			desc_proc.fork_at(_thisthread.high_background_priority, a_rope.copy(), append?)
			a_rope.empty()
		_endif
	_finally
		_if _not a_rope.empty?
		_then
			desc_proc.fork_at(_thisthread.high_background_priority, a_rope, append?)
		_endif
	_endloop

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.calculate_route(_gather args)
	## Start a thread to get the route.
	## 

	_local me << _self

	.thread <<
		_proc()
			_import me

			# Calculate the route
			me.int!calculate_route()
		_endproc.fork_at(_thisthread.high_background_priority)

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.int!calculate_route()
	## Send request to VE ACP to get route for waypoints.
	##

	_self.safe_current_coordinate_system()
	
	#_self.status << :running
	.thread << _thisthread
	_self.manage_actions()

	_self.install_progress_indicator("", _self,
					 :indicator, bar_progress_indicator,
					 :max_count, .waypoints.size,
					 :progress_aspect, :progress,
					 :stop_aspect, :done)

	_dynamic !current_world!
	_if (a_bus << _self.get_databus()) _isnt _unset _andif
	    (a_view << a_bus.request_data(:active_map_view)) _isnt unset
	_then
		!current_world! << a_view.world
	_endif 

	# Loop over the waypoints to get the route between each, and
	# compile that into a single list
	.route_results[:total_distance] << tot_dist << _unset
	.route_results[:total_time] << tot_time << _unset
	.route_results[:directions] << rope.new()
	.route_results[:route_path] << _unset
	a_rt << sector_rope.new()
	cnt << 0	

	start_id << wmc_route_item.get_table().size
	start_wp << .waypoints.first
	_protect

		_for ind _over range(2, .waypoints.size)
		_loop
			start_point << property_list.new_with(:location, start_wp.location,
							      :label,    start_wp.description)
			end_wp << .waypoints[ind]
			end_point << property_list.new_with(:location, end_wp.location,
							    :label,  end_wp.description)
			
			results << if_ve_acp.get_route_request(start_point,end_point)
			tot_dist << (_if tot_dist _is _unset
				     _then >> results[:total_distance]
				     _else >> tot_dist + results[:total_distance]
				     _endif)
			tot_time << (_if tot_time _is _unset
				     _then >> results[:total_time]
				     _else >> tot_time + results[:total_time]
				     _endif)
			_for r _over results[:directions].fast_elements()
			_loop
				id << (start_id + (cnt+<<1)).write_string
				.route_results[:directions].add(wmc_route_item.new_from_results(r, id))
			_endloop
			.route_results[:geometry_set] << _self.route_geometry_set()
			_if (a_path << results[:route_path]) _isnt _unset
			_then
				a_path.style_info << _self.style_for_route

				a_rt.add_sectors_last(a_path.sectors)
			_endif

			# Make the end_wp the next start_wp
			start_wp << end_wp

			# Update progress
			_self.changed(:progress, ind)
		_endloop 
		
		.route_results[:total_distance] << tot_dist
		.route_results[:total_time] << tot_time
		_if a_bus _isnt _unset _andif
		    a_rt _isnt _unset
		_then
			.route_results[:route_path] << pseudo_chain.new_for_world(a_rt, pseudo_world.new(!current_coordinate_system!))
			.route_results[:route_path].style_info << _self.style_for_route

			_if _self.using_google?
			_then
				# if we are using the Google API, then we don't need to draw
				# routes/waypoints on the map.  But we do need to explicitly
				# refresh the map so that the Google Static Map shows the
				# route.
				#a_view.render()
			_else 
				_self.databus.make_data_available(:geometry_to_draw, {.route_results[:route_path]}, _self)
			_endif
		_endif

	_protection
		_if _thisthread _is .thread
		_then
			.thread << _unset
		_endif 
		_self.changed(:route_results_list, :renew)
		_self.changed(:done)
		_self.manage_actions()
		#_self.status << :done
	_endprotect

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.clear_waypts(_gather args)
	##
	##  Auto-generated by Dialog Designer : 11/06/2009

	.waypoints.empty()
	.current_waypoint << _unset
	_self.changed(:waypt_list, :refresh)
	_self.manage_actions()

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.clear_results(_gather args)
	## Clear self's route results
	##

	_if (a_rt << .route_results[:route_path]) _isnt _unset
	_then 
		_self.databus.make_data_available(:geometry_to_undraw, {a_rt})
	_endif 

	.route_results.empty()
	_if (a_coll << wmc_route_item.get_collection(:wmc_route_item)) _isnt _unset _then
		_for a_rec _over a_coll.elements()
		_loop
			a_rec.delete()
		_endloop
	_endif
	
	_self.changed(:route_results_list, :refresh)
	_self.manage_actions()

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.on_deactivation(_gather args)
	## Clear self's waypoints and route results
	##

	_self.clear_waypts()
	_self.clear_results()
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.flash_direction()
	## Draws and undraws the designated geometries in rapid
	## succession, simulating a flash.
	# From MBuller

	_self.safe_current_coordinate_system()
	
	geoms << geometry_set.new()
	_for a_dt _over .items[:route_results].selection.fast_elements()
	_loop
		_if (a_item << a_dt.value) _isnt _unset _andif
		    a_item.is_kind_of?(wmc_route_item)
		_then
			geoms.add(a_loc << a_item.location)
		_endif
	_endloop

	_if _not geoms.empty?
	_then
		_proc(a_gs, a_db)
			_for i _over range(1,5)
			_loop
				a_db.make_data_available(:geometry_to_highlight, a_gs)
				_thisthread.sleep(200)
				a_db.make_data_available(:geometry_to_unhighlight, a_gs)
				_thisthread.sleep(200)
			_endloop
		_endproc.fork_at(_thisthread.background_priority, geoms, _self.databus)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.goto_direction()
	## Go to the given direction
	##

	_self.safe_current_coordinate_system()
	
	a_gs << geometry_set.new()
	_for a_dt _over .items[:route_results].selection.fast_elements()
	_loop
		_if (a_item << a_dt.value) _isnt _unset _andif
		    a_item.is_kind_of?(wmc_route_item)
		_then
			a_gs.add(a_item.location)
		_endif
	_endloop
	_if _not a_gs.empty?
	_then 
		_self.databus.make_data_available(:goto_request, {a_gs})
	_endif

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.move_waypts(to_pos)
	## Move waypoint(s) in list
	##

	_if .current_waypoint _isnt _unset _andif
	    _not .current_waypoint.empty?
	_then
		keys << rope.new()

		_for a_wp _over .current_waypoint.fast_elements()
		_loop
			keys.add(a_wp.key)
		_endloop
		.waypoints.move_waypts(keys, to_pos)
		_self.changed(:waypt_list, :refresh)
		_self.manage_actions()
	_endif

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.remove_waypt(_gather args)
	## Removes selected waypoint
	##

	_for a_sel _over .items[:waypt_list].selection.fast_elements()
	_loop
		.waypoints.remove(a_sel.key)
	_endloop

	_self.changed(:waypt_list, :refresh)

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.reverse_waypts(_gather args)
	## Reverse the waypoint list
	##

	.waypoints << .waypoints.reversed()
	_self.changed(:waypt_list, :refresh)

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.roundtrip_waypts(_gather args)
	## Reverse the waypoint list
	##

	.waypoints.add_roundtrip()
	_self.changed(:waypt_list, :refresh)

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.route_results_list
	## Display the route results
	##

	_self.safe_current_coordinate_system()
	
	a_rope << rope.new()

	_if .route_results.empty?
	_then
		_return a_rope
	_endif
	
	dist_unit << _self.action(:distance_units).value

	title_styled_string << styled_string.new(:value, :name, :colon, :mediumblue, :value, :amount)
	a_dt << display_tree.new(1, property_list.new_with(
					    :name, "Total Distance",
					    :amount, .route_results[:total_distance].convert_to(dist_unit)))
	a_dt.styled_string << title_styled_string
	a_rope.add(a_dt)
	a_dt << display_tree.new(2, property_list.new_with(
					    :name, "Total Time",
					    :amount, .route_results[:total_time].write_string))
	a_dt.styled_string << title_styled_string
	a_rope.add(a_dt)

	n_res << .route_results[:directions].size
	_for a_key, a_res _over .route_results[:directions].fast_keys_and_elements()
	_loop
		_if a_key _is 1
		_then
			a_dt << display_tree.new(a_key+2, a_res)
			a_dt.styled_string << a_res.styled_string({:start, _self.module_name}, dist_unit)
			a_rope.add(a_dt)
		_elif a_key _is n_res
		_then
			a_dt << display_tree.new(a_key+2, a_res)
			a_dt.styled_string << a_res.styled_string({:end, _self.module_name}, dist_unit)
			a_rope.add(a_dt)
		_elif a_res.waypoint?
		_then
			a_dt << display_tree.new(a_key+2, a_res)
			a_dt.styled_string << a_res.styled_string({:intermediate_wp, _self.module_name}, dist_unit)
			a_rope.add(a_dt)
		_else
			a_st << display_tree.new(a_key+2, a_res, a_dt)
			a_st.styled_string << a_res.styled_string(_unset, dist_unit)
			a_dt.expanded? << _true
		_endif
	_endloop

	>> a_rope
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.route_geometry_set()
	## Gather up the geometries for the route
	##
	_self.safe_current_coordinate_system()
	
	geoms << geometry_set.new()
	_for a_res _over .route_results[:directions].fast_elements()
	_loop
		geoms.add(a_res.location)
	_endloop

	>> geoms
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.route_results_selected(a_sel, _gather args)
	##
	##  Auto-generated by Dialog Designer : 11/06/2009

	#_global a_item
	#_if a_sel.an_element() _isnt _unset
	#_then
	#	a_item << a_sel.an_element().value
	#_endif
	#_self.flash_direction(a_sel)

	_self.manage_actions()
_endmethod
$

_pragma(classify_level=advanced, topic={Cornerstone,plotting})
_method wmc_route_finder.route_result_right_click(p_tree,p_row_index,p_event,
						  p_in_col_headings?,p_menu)
	## Adds the "Goto" and "Flash" items to the Popup menu P_MENU.
	##
	## P_TREE             - the display tree that the user clicked on
	##                      (or unset if the user clicked in the column headings
	##                      or below the last element)
	## P_ROW_INDEX        - index of p_tree in the list of visible display trees.
	## P_EVENT            - the event that has been raised; can be unset,
	##                      for example on a first invocation
	## P_IN_COL_HEADINGS? - boolean, true if the click position is in the
	##                      column headings row, false otherwise.
	## P_MENU             - the current menu that will be shown; this is the
	##                      headings shortcut menu if p_in_col_headings? is true,
	##                      and the main shortcut menu otherwise.

#	_if p_tree _is _unset _then _return _endif
#	
#	goto_selector << :goto_direction|()|
#	goto_selector_exists?? << _false
#	flash_selector << :flash_direction|()|
#	flash_selector_exists?? << _false
#
#	_for menu_item _over p_menu.items.fast_elements()
#	_loop
#		_if menu_item.is_kind_of?(button_item)
#		_then 
#			_if menu_item.selector _is flash_selector
#			_then
#				flash_selector_exists?? << _true
#			_elif menu_item.selector _is goto_selector
#			_then
#				goto_selector_exists?? << _true
#			_endif
#		_endif
#	_endloop
#
#	_if _not flash_selector_exists??
#	_then
#		button_item.new(p_menu, _self.message(:flash_direction), _self, flash_selector)
#	_endif
#
#	_if _not goto_selector_exists??
#	_then
#		button_item.new(p_menu, _self.message(:goto_direction), _self, goto_selector)
#	_endif

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.save_results(_gather args)
	##  Activate the file selector to save route results
	##
	_self.safe_current_coordinate_system()
	
	_self.file_selector(:save_results, :save_as).activate()

_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method wmc_route_finder.int!save_results(filename)
	## Save route results to file
	##
	
	# Save the diretory
	.items[:save_results_dir] << filename

	# Save routes to file
	_if (fs << external_text_output_stream.new(filename)) _is _unset
	_then _return _endif

	_protect
		fs.write("Total Distance: ", .route_results[:total_distance].write_string, newline_char)
		fs.write("Total Time: ", .route_results[:total_time].write_string, newline_char)
		fs.write(%-*40, newline_char, newline_char)

		_for a_key, a_res _over .route_results[:directions].fast_keys_and_elements()
		_loop
			_if _not a_res.waypoint? _andif
			    a_key _isnt 1
			_then
				fs.write(tab_char)
			_endif
			fs.write(a_res, newline_char)
		_endloop
	_protection
		fs.close()
	_endprotect 

_endmethod
$


_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.save_waypts(_gather args)
	##
	##
	
	_self.file_selector(:save_waypts, :save_as).activate()

_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method wmc_route_finder.int!save_waypts(filename)
	## Save waypoints to file
	##

	
	# Save the directory
	.items[:save_waypts_dir] << filename

	# Open the file
	_if (fs << external_text_output_stream.new(filename)) _is _unset
	_then
		condition.raise(:user_error, :string, "Cannot open file " + filename + " for writing.")
	_endif

	# Save the waypoints
	_protect
		.waypoints.write_on(fs)
	_protection
		fs.close()
	_endprotect 
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.load_waypts(_gather args)
	##
	##

	_self.file_selector(:load_waypts, :open).activate()

_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method wmc_route_finder.int!load_waypts(filename)
	## Save waypoints to file
	##

	_dynamic !current_coordinate_system!
	
	_self.safe_current_coordinate_system()

	# Save the diretory
	.items[:load_waypts_dir] << filename

	# Open the file
	_if (fs << external_text_input_stream.new(filename)) _is _unset
	_then
		condition.raise(:user_error, :string, "Cannot open file " + filename + " for reading.")
	_endif

	# Load the waypoints
	_dynamic !current_world!
	_if (a_bus << _self.get_databus()) _isnt _unset _andif
	    (a_view << a_bus.request_data(:active_map_view)) _isnt unset
	_then
		!current_world! << a_view.world
	_endif 
	_protect
		.waypoints << wmc_waypoint_list.new_from_stream(fs)
		_self.changed(:waypt_list, :refresh)
		_self.manage_actions()
	_protection
		fs.close()
	_endprotect 

_endmethod
$

_pragma(classify_level=restricted, usage={redefinable})
_method wmc_route_finder.file_selector(which, op)
	##  Create a file selector of type WHICH
	##
	
	_if .items[which] _is _unset
	_then
		dir << system.getenv("TEMP").default("c:\temp")
		.items[which] <<
			file_dialog.new(_self, :int! + which + :|()|, :class_name,
					:filter,"*.*",
					:directory, dir)
	_else
		.items[which].directory << .items[which + :_dir]
	_endif

	fs << .items[which]
	fs.operation << op

	fs.ok_message << :int! + which + :|()|
	fs.title << _self.message(which)

	>> .items[which]
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.sort_waypts(_optional sort_type)
	## Sort the waypoints in a given manner.
	##

	_self.safe_current_coordinate_system()
	
	sort_type << sort_type.default(:salesman)
	
	.waypoints.sort(sort_type)
	_self.changed(:waypt_list, :refresh)

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.waypt_changed(_gather args)
	##
	##  Auto-generated by Dialog Designer : 11/06/2009

	_self.dd_default_method("wmc_route_finder.waypt_changed()",_scatter args)
_endmethod
$

_pragma(classify_level=advanced)
_method wmc_route_finder.show_in_web_browser(list_type, _optional map_type)
	## calls "start <map URL>".  This will launch the default
	## browser and direct it to maps.live.com with suitable lat/lon
	## and zoom scale information set.

	_self.safe_current_coordinate_system()
	
	_if list_type _is :route
	_then
		(a_coord, a_title) << (_for a_res _over .items[:route_results].selection.fast_elements()
			    _loop
				    _if (a_item << a_res.value) _isnt _unset _andif
					a_item.is_kind_of?(wmc_route_item)
				    _then
					    _leave _with a_item.location.coordinate,
					    a_item.write_string
				    _endif
			    _endloop)
	_else
		a_coord << .current_waypoint.an_element().value[:location].coordinate
		a_title << .current_waypoint.an_element().value[:name]
	_endif

	_local (zoom_level,centre_lon_lat) << _self.zoom_level(a_coord)

	_if map_type _is _unset 
	_then
		_local a_bus << _self.get_databus()
		map_type << a_bus.request_data(:wmc_map_type)
	_endif

	if_ve_acp.int!show_in_web_browser(zoom_level,centre_lon_lat,map_type, a_title)
	

_endmethod
$

_pragma(classify_level=basic)
_method wmc_route_finder.zoom_level(a_coord)
	## zoom_level : integer,coordinate
	##
	## returns the Virtual Earth zoom level (aka Level of Detail)
	## for the map currently associated with self.  Also returns
	## the coordinate (in lon/lat) that was used to determine this
	## zoom_level. 

	an_app << _self.application
	
	_dynamic !current_coordinate_system!

	_if !current_coordinate_system! _is _unset _andif
	    an_app _isnt _unset 
	_then
		!current_coordinate_system! << an_app.coordinate_system
	_endif 

	_self.safe_current_coordinate_system()

	a_bus << _self.get_databus()
	a_map_view << a_bus.request_data(:active_map_view)
	t << transform.new_converting_cs_to_cs(!current_coordinate_system!,_self.dataset_exemplar.LONGLAT_COORDINATE_SYSTEM)
	centre_lon_lat << t.convert(a_coord)
	lat << centre_lon_lat.y

	_return wmc_rwo_record.get_level_of_detail(lat,
						   a_map_view.view_scale,
						   a_map_view.wmc_dpi).min(21),
 	        centre_lon_lat
_endmethod
$
_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.zoom_to_route(_gather args)
	## Zoom to calculated route
	##

	_dynamic !current_coordinate_system!

	_self.safe_current_coordinate_system()

	_if .route_results[:route_path] _isnt _unset 
	_then
		_self.databus.make_data_available(:goto_request, {.route_results[:route_path].bounds.new_enlarging(1.1)})
	_endif
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.set_trail_from_route(_gather args)
	## Set the map trail from the route geometry
	##

	_if .route_results[:route_path] _isnt _unset 
	_then
		_self.databus.make_data_available(:set_map_trail, {_self, .route_results[:route_path]})
	_endif
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.set_route_style(a_style_type, _gather args)
	## Set route style when a style type is selected
	##

	#show(a_style_type, _scatter args)

	_self.style_for_route << a_style << 
		line_style.new_with_properties(
			:foreground_colour, _self.action(:route_style_color).value,
			:dash_pattern, _self.action(:route_style_dash).value,
			:width, _self.action(:route_style_width).value)

	_if _self.get_databus() _isnt _unset _andif
	    (a_rt << .route_results[:route_path]) _isnt _unset
	_then
		a_rt.style_info << a_style
		_self.databus.make_data_available(:geometry_to_draw, {a_rt, a_rt.style_info}, _self)
	_endif
	
_endmethod
$
_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.set_wp_style(_gather args)
	## Set route style when a style type is selected
	##

	#show(a_style_type, _scatter args)

	_if _self.get_databus() _isnt _unset _andif
	    (a_gs << _self.post_render_geometries()) _isnt _unset
	_then
		_self.databus.make_data_available(:geometry_to_draw,
						  {a_gs, a_gs.style_info}, _self)
	_endif
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.dataset_exemplar
	## returns the *_dataset exemplar that is based on the current
	## geocoding_api_vendor_name 

	_dynamic !current_package!
	
	_return !current_package!.all_packages[:user][(if_ve_acp.geocoding_api_vendor_name + :_dataset).as_symbol()]
_endmethod
$
_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.dataset_manager_exemplar
	## returns the *_dataset_manager exemplar that is based on the current
	## geocoding_api_vendor_name 

	_dynamic !current_package!
	
	_return !current_package!.all_packages[:user][(if_ve_acp.geocoding_api_vendor_name + :_dataset_manager).as_symbol()]
_endmethod
$

_pragma(classify_level=advanced)
_method wmc_route_finder.dataset_open?
	## 
	##

	# for some reason, when this gets saved as a .magikc file, it
	# cannot be read at certain customer sites.  Some error about
	# "set_name".  Trying to break this into two lines to see if
	# that helps the compiler.
	_local ds_name << _self.dataset_exemplar.DATASET_NAME
	
	_return gis_program_manager.cached_dataset(ds_name) _isnt _unset 
_endmethod
$

_pragma(classify_level=advanced)
_method wmc_route_finder.open_dataset()
	## 
	##

	_local dataset_action << _unset

	_if _not _self.dataset_open?
	_then
		_if _not if_ve_acp.has_credential_info_been_loaded?
		_then
			condition.raise(:ve_credentials_need_to_be_loaded)
		_endif
		
		_self.add_dataset()
	_endif

_endmethod
$

_pragma(classify_level=advanced)
_method wmc_route_finder.add_dataset()
	## 
	##

	vedsm << _self.dataset_manager_exemplar.startup()
	a_soc << gis_program_manager.spatial_object_controller (:gis)
	_if a_soc _isnt _unset 
	_then
		a_soc.add_dataset_manager(vedsm)
	_endif

_endmethod
$

_pragma(classify_level=restricted)
_method wmc_route_finder.manage_vhs_settings()
	## manage_vhs_settings() : _unset
	##
	## manages the VHS settings on the current ace_control

	an_app << (_for app _over smallworld_product.applications.fast_elements()
		   _loop
			   _if _not app.is_kind_of?( sw:admin_application )
			   _then _leave _with app
			   _endif
		   _endloop)
	ac    << an_app.get_ace_control_for(an_app.ace_name)

	# for some reason, when this gets saved as a .magikc file, it
	# cannot be read at certain customer sites.  Some error about
	# "set_name".  Trying to break this into two lines to see if
	# that helps the compiler.
	_local ds_name << _self.dataset_exemplar.DATASET_NAME

	colls << gis_program_manager.cached_dataset(ds_name).collections
	route_item << colls[:wmc_route_item].field(:location)
	display_scale_names << ac.scale_label_list
	
	ac.set_visibility_for_display_scales({route_item},_true,_scatter display_scale_names)
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.read_route_from_file(filename)
	##
	##

	_if (fs << external_text_input_stream.new(filename)) _is _unset
	_then
		_return
	_endif

	_dynamic !current_coordinate_system! << _self.dataset_exemplar.longlat_coordinate_system

	_dynamic !current_world!
	_if (a_bus << _self.get_databus()) _isnt _unset _andif
	    (a_view << a_bus.request_data(:active_map_view)) _isnt unset
	_then
		!current_world! << a_view.world
	_endif 
	
	_protect
		.route_results[:total_distance] << unit_value.new_from_string(fs.get_line())
		.route_results[:total_time] << fs.get_line()
		.route_results[:directions] << rope.new()
		start_id << wmc_route_item.get_table().size
		cnt << 0
		_loop
			_if (a_line << fs.get_line()) _is _unset
			_then _leave _endif

			a_vec << a_line.split_by(%,)
			id << (start_id + (cnt+<<1)).write_string
			.route_results[:directions].add(
					wmc_route_item.new_from_results(
						property_list.new_with(
							:latitude, a_vec[1].as_number(),
							:longitude, a_vec[2].as_number(),
							:distance, unit_value.new_from_string(a_vec[4]),
							:time, time_interval.new_seconds(a_vec[5].as_number()),
							:text, a_vec[3]),
						id
						       )
						    )
		_endloop
		.route_results[:geometry_set] << _self.route_geometry_set()

	_protection
		fs.close()
		_self.changed(:route_results_list, :renew)
		_self.manage_actions()
	_endprotect

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_method wmc_route_finder.dd_default_method(_gather args)
	##
	##  Auto-generated by Dialog Designer : 11/06/2009
	##
	##  General default method writing CLASS.METHOD and passed ARGS to
	##  the Magik> prompt.

	msg << write_string("Auto-generated : ",args[1],%newline)

	_if args.size > 1
	_then
		msg +<< write_string(%newline,args.size-1," parameter(s) passed:")
 	_endif

	_for i _over 2.upto(args.size)
	_loop
		msg +<< write_string(%newline,"         ",args[i])
	_endloop

	write(%newline,"-"*80,%newline,msg)
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_route_finder})
_private _method wmc_route_finder.using_google?
	## using_google? : boolean
	##
	## indicates if the current geocoding API is "google"

	_return _false
	
	_dynamic !current_package!
	 
	_return !current_package!.all_packages[:user][:google_rwo_record] _isnt _unset _andif
		if_ve_acp.geocoding_api_vendor_name = "google"
_endmethod
$

