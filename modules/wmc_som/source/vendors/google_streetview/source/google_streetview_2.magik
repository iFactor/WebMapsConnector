#% text_encoding = iso8859_1
##-----------------------------------------------------------------------------------------------
## Web Maps Connector (which shows web maps as layers in Smallworld(TM) Core Spatial Technology)
## Copyright (C) 2017 KUBRA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http:##www.gnu.org/licenses/>.
##
## You may contact KUBRA at https://kubra.com/contact-us/
##-----------------------------------------------------------------------------------------------

##
##  Auto-generated by Dialog Designer v2.6 : 18/04/2012
##
##  System.user_mame = Alfred
##
##  SUPPLIMENTARY code for gui class 'google_streetview'
##    - add/redefine code here, it will not be auto-modified.

_package user
$

_pragma(classify_level=advanced)
##
## The name of a map_manager plugin.
##
google_streetview.def_property( :map_manager_name,
	:type, :symbol )
$
_pragma(classify_level=restricted)
_method google_streetview.map_manager
	##
	## Return the map manager
	## If the map_manager_name property is set, then this will
	## return the named plugin.
	## If not, it will return the first plugin that provides the
	## :map_manager service.
	##

	>> _if ( plugin_name << _self.property(:map_manager_name) ) _isnt _unset
	   _then
		   >> _self.framework.plugin( plugin_name )
	   _else
		   >> _self.get_service_provider( :map_manager )
	   _endif
	
_endmethod
$
_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.custom_build_gui(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.6 : 18/04/2012

	.items[:fov] << 90
	.items[:heading] << _unset 
	.items[:heading] << 0
	
_endmethod
$
_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.canvas
	_return .items[:scrollable_canvas_01]
_endmethod
$

_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.get_memory_canvas(actual_window_canvas)
	## get_memory_canvas(canvas ACTUAL_WINDOW_CANVAS) : memory_canvas
	##
	##

	_local ret_canvas
	
	_if .items[:memory_canvas] _isnt _unset
	_then
		_if .items[:memory_canvas].width = actual_window_canvas.width _andif
		    .items[:memory_canvas].height = actual_window_canvas.height
		_then
			# if the cached memory_canvas is the same size as the
			# ACTUAL_WINDOW_CANVAS, then reuse it.
			ret_canvas << .items[:memory_canvas]
		_else 
			# if the cached memory_canvas is a different size, then discard
			# the cached one and create a new memory canvas
			.items[:memory_canvas].destroy()
			ret_canvas << .items[:memory_canvas] << memory_canvas.new(actual_window_canvas.width,
										  actual_window_canvas.height)
		_endif
	_else
		# if we have no cached memory_canvas, then create one.
		ret_canvas << .items[:memory_canvas] << memory_canvas.new(actual_window_canvas.width,
									  actual_window_canvas.height)
	_endif 

	_return ret_canvas
_endmethod
$



_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.post_activation(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.6 : 18/04/2012

	_local a << _self.canvas.agent

	a.define_redraw(:refresh_view|()|,_self)
	a.define_button( :|button_released()|,_self,:select)
	a.define_locator( :|changed_mouse_position()|,_self,:drag)
	
_endmethod
$
_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.button_released(x,y)


	_if .items[:originalX] _is _unset 
	_then
		# do nothing because the user didn't actually drag the mouse
		# before releasing the button
		_return 
	_endif

	_local delta_x << x - .items[:originalX]
	_local delta_y << y - .items[:originalY]

	.items[:originalX] << _unset 
	.items[:originalY] << _unset

	# now we refresh the map
	.items[:heading] +<< ((.items[:fov] / _self.canvas.width) * delta_x * -1)
	pitch << .items[:pitch]
	
	pitch +<< ((.items[:fov] / _self.canvas.height) * delta_y)
	pitch << pitch.max(-90.0).min(90.0) * 1.0


	.items[:pitch] << pitch

	_self.refresh_view()
_endmethod
$
_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.changed_mouse_position(x,y)

	_if .items[:originalX] _is _unset 
	_then
		.items[:originalX] << x
		.items[:originalY] << y
	_endif
	
	_local delta_x << x - .items[:originalX]
	_local delta_y << y - .items[:originalY]

	_if delta_x <> 0 _orif
	    delta_y <> 0
	_then
		_self.copy_memory_canvas_to_canvas(-delta_x,-delta_y)
	_endif
_endmethod
$


_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.get_streetview(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.6 : 18/04/2012

	# get the current trail info
	_dynamic !print_float_precision! << 12
	_local a_trail << _self.map_manager.current_trail

	_if a_trail.empty?
	_then
		_return 
	_endif
	_local tr << transform.new_converting_cs_to_cs(a_trail.coordinate_system,wmc_dataset.longlat_coordinate_system)
	_local first_coord << tr.convert(a_trail.first_coord)


	_local pl << property_list.new()
	.items[:latitude] << first_coord.y
	.items[:longitude] << first_coord.x

	_if a_trail.coords.size > 1
	_then
		.items[:heading] << (((tr.convert(a_trail.first_coord).angle_to(tr.convert(a_trail.last_coord)).radians_to_degrees) * -1) + 90)
		
	_else
		.items[:heading] << 0
	_endif

	.items[:pitch] << 0
	.items[:fov] << 90
	
	# then draw the streetview
	_self.refresh_view()
_endmethod
$

_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.refresh_view()

	# for the given trail, get a streetview

	_dynamic !print_float_precision! << 12
	_local a_trail << _self.map_manager.current_trail

	_if a_trail.empty?
	_then
		_return 
	_endif
	_local tr << transform.new_converting_cs_to_cs(a_trail.coordinate_system,wmc_dataset.longlat_coordinate_system)
	_local first_coord << tr.convert(a_trail.first_coord)


	_local pl << property_list.new()
	pl[:size] << write_string(_self.canvas.width,"x",_self.canvas.height)
	pl[:latitude] << .items[:latitude]
	pl[:longitude] << .items[:longitude]
	pl[:heading] << .items[:heading]
	pl[:fov] << .items[:fov]
	pl[:pitch] << .items[:pitch]

	_local mem_cv << _self.get_memory_canvas(_self.canvas)
	user:if_ve_acp.draw_tiles(mem_cv,pl)

	_self.copy_memory_canvas_to_canvas(0,0)
	
_endmethod
$
_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.copy_memory_canvas_to_canvas(delta_x,delta_y)

	_local target << _self.canvas
	_local source << .items[:memory_canvas]

	target.clear()
	target.copy_area(-delta_x,-delta_y,
			 source.width,source.height,
			 source,
			 0,0)
	
_endmethod
$



_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.zoom_in(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.6 : 18/04/2012

	_local fov << .items[:fov]

	fov -<< 15

	.items[:fov] << fov.max(0)

	_self.refresh_view()
	
_endmethod
$

_pragma(classify_level=restricted, topic={google_streetview})
_method google_streetview.zoom_out(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.6 : 18/04/2012

	_local fov << .items[:fov]

	fov +<< 15

	.items[:fov] << fov.min(120)

	_self.refresh_view()
	
_endmethod
$
