#% text_encoding = iso8859_1
##-----------------------------------------------------------------------------------------------
## Web Maps Connector (which shows web maps as layers in Smallworld(TM) Core Spatial Technology)
## Copyright (C) 2017 KUBRA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http:##www.gnu.org/licenses/>.
##
## You may contact KUBRA at https://kubra.com/contact-us/
##-----------------------------------------------------------------------------------------------

##
##  Auto-generated by Dialog Designer v2.2 : 21/01/2011
##
##  System.user_mame = Alfred
##
##  SUPPLIMENTARY code for gui class 'canvas_comparer'
##    - add/redefine code here, it will not be auto-modified.

_package user
$

_pragma(classify_level=restricted, topic={canvas_comparer})
_method canvas_comparer.post_activation(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.2 : 21/01/2011

	_local a << .items[:scrollable_canvas_01].agent

	a.define_locator(:dragged_mouse_position|()|,_self,:drag)
	a.define_redraw(:refresh_view|()|,_self)
	
	.items[:mouse_position_x] << 0
	.items[:mouse_position_y] << 0
_endmethod
$
_pragma(classify_level=advanced, topic={canvas_comparer})
_method canvas_comparer.current_canvas
	## current_canvas : canvas
	##
	## returns the canvas from which to take a snapshot 

	# this should be fixed to be more flexible.
	_return smallworld_product.applications.an_element().plugin("maps").current_map_view.window
_endmethod
$


_pragma(classify_level=restricted, topic={canvas_comparer})
_method canvas_comparer.image_toggle_item_01(flag?)
	## image_toggle_item_01(boolean FLAG?) : _unset
	##
	## puts a snapshot of current canvas into .items[:canvas_1] 

	_self.int!canvas_helper(flag?,:canvas_1)
_endmethod
$

_pragma(classify_level=restricted, topic={canvas_comparer})
_method canvas_comparer.image_toggle_item_02(flag?)
	## image_toggle_item_02(boolean FLAG?) : _unset
	##
	## puts a snapshot of current canvas into .items[:canvas_2] 

	_self.int!canvas_helper(flag?,:canvas_2)
_endmethod
$
_pragma(classify_level=restricted, topic={canvas_comparer})
_method canvas_comparer.image_toggle_item_03(flag?)
	## image_toggle_item_03(boolean FLAG?) : _unset
	##
	## puts a snapshot of current canvas into .items[:canvas_3] 

	_self.int!canvas_helper(flag?,:canvas_3)
_endmethod
$
_pragma(classify_level=restricted, topic={canvas_comparer})
_method canvas_comparer.image_toggle_item_04(flag?)
	## image_toggle_item_04(boolean FLAG?) : _unset
	##
	## puts a snapshot of current canvas into .items[:canvas_4] 

	_self.int!canvas_helper(flag?,:canvas_4)
_endmethod
$
_pragma(classify_level=restricted, topic={canvas_comparer})
_private _method canvas_comparer.int!canvas_helper(flag?,internal_canvas_name)
	## int!canvas_helper(boolean FLAG?,
	##                   symbol INTERNAL_CANVAS_NAME) : _unset
	##
	## helper method to snapshot and set the appropriate canvas
	## slots. 

        _local current_canvas << _self.current_canvas
	_local width << current_canvas.width
	_local height << current_canvas.height
	
	_if .items[internal_canvas_name] _is _unset 
	_then
		.items[internal_canvas_name] << memory_canvas.new(width,height)
	_endif
	
	_if flag?
	_then
		.items[internal_canvas_name].copy_area(0,0,width,height,current_canvas,0,0)
		.items[:scrollable_canvas_01].copy_area(0,0,width,height,current_canvas,0,0)
	_else
		.items[internal_canvas_name].clear()
	_endif

	_self.refresh_view()
_endmethod
$
_pragma(classify_level=restricted, topic={canvas_comparer})
_method canvas_comparer.dragged_mouse_position(x,y)
	## dragged_mouse_position(integer X,
	##                        integer Y) : _unset

	.items[:mouse_position_x] << x
	.items[:mouse_position_y] << y

	_self.refresh_view()
_endmethod
$
_pragma(classify_level=restricted, topic={canvas_comparer})
_method canvas_comparer.refresh_view()

	_self.compare()

_endmethod
$
_pragma(classify_level=restricted, topic={canvas_comparer})
canvas_comparer.define_shared_constant(:edge_line_style,
	                               line_style.new(colour.called(:gray),1),
				       _false)
$
	
_pragma(classify_level=restricted, topic={canvas_comparer})
_method canvas_comparer.compare()

	_local x << .items[:mouse_position_x]
	_local y << .items[:mouse_position_y]

	_local a_canvas, width, height
	
	_if (a_canvas << .items[:canvas_1]) _isnt _unset 
	_then 
		width << a_canvas.width
		height << a_canvas.height
		.items[:scrollable_canvas_01].copy_area(0,0,x,y,
							a_canvas,0,0)
	_endif
	
	_if (a_canvas << .items[:canvas_2]) _isnt _unset 
	_then 
		width << a_canvas.width
		height << a_canvas.height
		.items[:scrollable_canvas_01].copy_area(x,0,width-x,y,
							a_canvas,x,0)
	_endif 

	_if (a_canvas << .items[:canvas_3]) _isnt _unset 
	_then 
		width << a_canvas.width
		height << a_canvas.height
		.items[:scrollable_canvas_01].copy_area(0,y,x,height-y,
							a_canvas,0,y)
	_endif 

	_if (a_canvas << .items[:canvas_4]) _isnt _unset 
	_then 
		width << a_canvas.width
		height << a_canvas.height
		.items[:scrollable_canvas_01].copy_area(x,y,width-x,height-y,
							a_canvas,x,y)
	_endif 

	_if height _isnt _unset _andif
	    width _isnt _unset 
	_then
		# vertical line
		.items[:scrollable_canvas_01].draw_line(_self.edge_line_style,
							short_integer_vector.new_with(x.min(width).max(1),0,
										      x.min(width).max(1),height))
		# horizontal line
		.items[:scrollable_canvas_01].draw_line(_self.edge_line_style,
							short_integer_vector.new_with(0,y.min(height).max(1),
										      width,y.min(height).max(1)))
	_endif
_endmethod
$


