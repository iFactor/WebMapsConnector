#% text_encoding = iso8859_1
##-----------------------------------------------------------------------------------------------
## Web Maps Connector (which shows web maps as layers in Smallworld(TM) Core Spatial Technology)
## Copyright (C) 2017 KUBRA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http:##www.gnu.org/licenses/>.
##
## You may contact KUBRA at https://kubra.com/contact-us/
##-----------------------------------------------------------------------------------------------

_package user
$

_pragma(classify_level=restricted, topic={map_view_comparer})
## a sub-class of canvas_comparer that works specifically on
## the current map view
def_slotted_exemplar(:map_view_comparer,
	{},
	:canvas_comparer)
$

_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.post_activation(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.2 : 21/01/2011

	.items << property_list.new()

	.items[:mouse_position_x] << 0
	.items[:mouse_position_y] << 0

	.items[:compare_method] << :compare_left_right|()|

	#.items[:image_toggle_item_top_bottom].value << _true 
_endmethod
$
_pragma(classify_level=advanced, topic={map_view_comparer})
_method map_view_comparer.current_canvas
	## current_canvas : canvas
	##
	## returns the canvas from which to take a snapshot 

	_return _self.application.plugin("maps").current_map_view.window
_endmethod
$
_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.scrollable_canvas

	_return _self.current_canvas
_endmethod
$



_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.image_toggle_item_01(flag?)
	## image_toggle_item_01(boolean FLAG?) : _unset
	##
	## puts a snapshot of current canvas into .items[:canvas_1] 

	_self.int!canvas_helper(flag?,:canvas_1)
_endmethod
$

_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.image_toggle_item_02(flag?)
	## image_toggle_item_01(boolean FLAG?) : _unset
	##
	## puts a snapshot of current canvas into .items[:canvas_2] 

	_self.int!canvas_helper(flag?,:canvas_2)
_endmethod
$

_pragma(classify_level=restricted, topic={map_view_comparer})
_private _method map_view_comparer.int!canvas_helper(flag?,internal_canvas_name)
	## int!canvas_helper(boolean FLAG?,
	##                   symbol INTERNAL_CANVAS_NAME) : _unset
	##
	## helper method to snapshot and set the appropriate canvas
	## slots. 

        _local current_canvas << _self.current_canvas
	_local width << current_canvas.width
	_local height << current_canvas.height
	
	_if .items[internal_canvas_name] _is _unset 
	_then
		.items[internal_canvas_name] << memory_canvas.new(width,height)
	_endif
	
	_if flag?
	_then
		.items[internal_canvas_name].copy_area(0,0,width,height,current_canvas,0,0)
		#_self.scrollable_canvas.copy_area(0,0,width,height,current_canvas,0,0)
	_else
		.items[internal_canvas_name].clear()
	_endif

	_self.int!set_canvas_mode()

	_self.refresh_view()
_endmethod
$
_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.int!set_canvas_mode()
	## int!set_canvas_mode() : _unset
	##
	## depending on the toggle button values, set the appropriate
	## mode on the canvas.

	_local original_canvas_agent_info << .items[:canvas_agent_info]
	_if original_canvas_agent_info _is _unset 
	_then
		original_canvas_agent_info << .items[:canvas_agent_info] << property_list.new()
	_endif

	_local a << _self.scrollable_canvas.agent


	_if _self.action(:image_toggle_item_01).value _is _true _andif
	    _self.action(:image_toggle_item_02).value _is _true 
	_then
		# if both toggles are set to _true, then we should store the
		# old canvas agent modes and replace them with the special ones
		# for comparing the canvas.

		original_canvas_agent_info[:redraw_func] << a.redraw_func.default({_unset,_unset})
		original_canvas_agent_info[:move_func] << a.move_func.default({_unset,_unset})
		
		a.define_locator(:moved_mouse_position|()|,_self,:move)
		a.define_redraw(:refresh_view|()|,_self)

	_elif _self.action(:image_toggle_item_01).value _is _false _orif 
	      _self.action(:image_toggle_item_02).value _is _false
	_then 
		# if even one of the toggles is set to _false, then we need to
		# revert back to the original canvas agent modes.
		a.define_locator(original_canvas_agent_info[:move_func][1],
				 original_canvas_agent_info[:move_func][2],
				 :move)
		a.define_redraw(_scatter original_canvas_agent_info[:redraw_func])
	_endif
	
	
_endmethod
$
_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.moved_mouse_position(x,y)
	## moved_mouse_position(integer X,
	##                        integer Y) : _unset

	.items[:mouse_position_x] << x
	.items[:mouse_position_y] << y

	_self.refresh_view()
_endmethod
$
_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.image_toggle_item_top_bottom(flag?)
	##
	##  Auto-generated by Dialog Designer v2.2 : 22/01/2011

	_if flag?
	_then
		_self.set_compare_mode(:top_bottom)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.image_toggle_item_left_right(flag?)
	##
	##  Auto-generated by Dialog Designer v2.2 : 22/01/2011

	_if flag?
	_then
		_self.set_compare_mode(:left_right)
	_endif
_endmethod
$
_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.set_compare_mode(compare_mode)
	## set_compare_mode(symbol COMPARE_MODE) : _unset
	## sets the compare mode for self.

	.items[:compare_method] << :compare_ + compare_mode + :|()|

	_for i_mode_name _over {:top_bottom,
				:left_right}.fast_elements()
	_loop
		_self.action(:image_toggle_item_ + compare_mode).set_value(i_mode_name _is compare_mode)
	_endloop
	
_endmethod
$


_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.refresh_view()

	_self.perform(.items[:compare_method])

_endmethod
$
_pragma(classify_level=restricted, topic={map_view_comparer})
map_view_comparer.define_shared_constant(:edge_line_style,
	                               line_style.new(colour.called(:black),5),
				       _false)
$
	
_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.compare_left_right()

	_local x << .items[:mouse_position_x]
	_local y << .items[:mouse_position_y]

	_local a_canvas, width, height
	
	_if (a_canvas << .items[:canvas_1]) _isnt _unset 
	_then 
		width << a_canvas.width
		height << a_canvas.height
		_self.scrollable_canvas.copy_area(0,0,x,height,
							a_canvas,0,0)
	_endif
	
	_if (a_canvas << .items[:canvas_2]) _isnt _unset 
	_then 
		width << a_canvas.width
		height << a_canvas.height
		_self.scrollable_canvas.copy_area(x,0,width-x,height,
							a_canvas,x,0)
	_endif 

	_if height _isnt _unset _andif
	    width _isnt _unset 
	_then
		_self.scrollable_canvas.draw_line(_self.edge_line_style,
							short_integer_vector.new_with(x.min(width).max(1),0,
										      x.min(width).max(1),height))
	_endif
_endmethod
$
_pragma(classify_level=restricted, topic={map_view_comparer})
_method map_view_comparer.compare_top_bottom()

	_local x << .items[:mouse_position_x]
	_local y << .items[:mouse_position_y]

	_local a_canvas, width, height
		
	_if (a_canvas << .items[:canvas_1]) _isnt _unset 
	_then
		width << a_canvas.width
		height << a_canvas.height
		
		_self.scrollable_canvas.copy_area(0,0,width,y,
							a_canvas,0,0)
	_endif

	_if (a_canvas << .items[:canvas_2]) _isnt _unset
	_then 
		width << a_canvas.width
		height << a_canvas.height
		_self.scrollable_canvas.copy_area(0,y,width,height-y,
							a_canvas,0,y)
	_endif 

	_if width _isnt _unset _andif
	    height _isnt _unset 
	_then
		_self.scrollable_canvas.draw_line(_self.edge_line_style,
							short_integer_vector.new_with(0,y.min(height-1).max(1),
										      width,y.min(height-1).max(1)))
	_endif
_endmethod
$
