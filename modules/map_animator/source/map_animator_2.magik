#% text_encoding = iso8859_1
##-----------------------------------------------------------------------------------------------
## Web Maps Connector (which shows web maps as layers in Smallworld(TM) Core Spatial Technology)
## Copyright (C) 2017 KUBRA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http:##www.gnu.org/licenses/>.
##
## You may contact KUBRA at https://kubra.com/contact-us/
##-----------------------------------------------------------------------------------------------

##
##  Auto-generated by Dialog Designer v2.1 : 27/07/2010
##
##  System.user_mame = Alfred
##
##  SUPPLIMENTARY code for gui class 'map_animator'
##    - add/redefine code here, it will not be auto-modified.

_package user
$

_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.post_activation(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.1 : 27/07/2010

	.items[:delay_text_choice_item].value << :|250|
	.items[:frames_text_choice_item].value << :|6|
	
_endmethod
$
_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.slider_item_changed(slider_value)
	## slider_item_changed

	# start_time is the "as=0" time and all other history frames
	# are taken backward from there
	_local start_time << _self.items[:start_time]

	_if start_time _is _unset 
	_then
		start_time << _self.items[:start_time] << date_time_now()
	_endif
	
	_local frames_info << .items[:animation_frames_info]
	
	_if frames_info _is _unset 
	_then
		frames_info << .items[:animation_frames_info] << equality_property_list.new()
	_endif

	_local animation_filename

	_local frame_time_interval << .items[:interval_text_choice_item].value.as_number() * time_interval.new_seconds(60*5) # each interval is about 5 minutes.

	.items[:slider_item].label << _self.label_for_slider_value(slider_value,frame_time_interval,start_time)

	_local a_map_view << _self.map_view
	_local win << a_map_view.window

	_if (animation_filename << frames_info[slider_value]) _is _unset 
	_then
		animation_filename << system.temp_file_name("map_animator.bmp")
		_self.model.pre_render_for_slider_value(slider_value)
		_self.map_view.int!do_render()
		_self.model.post_render_for_slider_value(slider_value)
		win.copy_to_file(animation_filename,0,0,win.width,win.height)

		frames_info[slider_value] << animation_filename

	_else
		_thisthread.sleep(.items[:delay_text_choice_item].value.as_number())
		_local ri << raster_image.new_from_file(animation_filename)
		_protect
			win.render_raster(ri,0,0,_false)
		_protection
			ri.destroy()
		_endprotect
	_endif
	
_endmethod
$

_pragma(classify_level=restricted, topic={map_animator})
_private _method map_animator.map_view
	## map_view : map_view
	##
	## returns the map_view that the animation will play on.

	## FIXME FIXME: this should probably be defined as a plugin
	## property at some point.  For now we just hack it a bit. 
	_return smallworld_product.applications.an_element().plugin(:maps).current_map_view
_endmethod
$
_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.reset_button_item_selected()
	## reset_button_item_selected() : _unset
	##
	## resets the currently-cached animation frames.

	_self.reset()
	_self.slider_item_changed(0)
_endmethod
$
_pragma(classify_level=restricted, topic={map_animator})
_private _method map_animator.reset()
	## reset() : _unset
	##
	## resets the currently-cached animation frames.
	
	_local frames_info << .items[:animation_frames_info]
	
	_if frames_info _is _unset 
	_then
		frames_info << .items[:animation_frames_info] << equality_property_list.new()
	_endif
	
	_for x _over frames_info.fast_elements()
	_loop
		system.unlink(x,_unset,_true)
	_endloop

	frames_info.empty()

	_self.items[:start_time] << _unset 
_endmethod
$


_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.model
	## model : self
	##
	## for now, just returns _self.  Model is the class that the
	## map_animator will interact with for messages:
	##  :min_slider_value()
	##  :max_slider_value()
	##  :label_for_slider_value()
	##  :pre_render_for_slider_value()
	##  :post_render_for_slider_value()

	_return _self 
_endmethod
$

_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.label_for_slider_value(slider_value,frame_time_interval,base_date_time)
	## label_for_slider_value(integer SLIDER_VALUE,
	##                        time_interval FRAME_TIME_INTERVAL,
	##                        date_time BASE_DATE_TIME) : string
	##
	## 

	_return base_date_time.plus(slider_value * frame_time_interval).write_string
	
_endmethod
$
_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.pre_render_for_slider_value(slider_value)
	## pre_render_for_slider_value(integer SLIDER_VALUE) : _unset
	##
	## prepares the weather data with extra rendering information
	## (e.g., history parameter)
	_local increment_value << (slider_value * -1) * .items[:interval_text_choice_item].value.as_number()
	weatherbug_rwo_record.EXTRA_RENDERING_INFO << write_string("as=",increment_value)
_endmethod
$
_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.post_render_for_slider_value(slider_value)
	## pos_render_for_slider_value(integer SLIDER_VALUE) : _unset
	##
	## resets the weather data back to the pre-animation rendering
	## info. 

	weatherbug_rwo_record.EXTRA_RENDERING_INFO << "as=0"
_endmethod
$


_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.pause_image_button_item_selected()
	## pause_image_button_item_selected() : _unset
	##
	## stops the animation thread.  The user sees this as a "Pause"
	## but internally it is OK to kill the thread.

	_local a_thread << .items[:thread]

	_if a_thread _isnt _unset 
	_then
		a_thread.kill()
		# need to sleep a little bit so that the thread is completely
		# killed before we call :manage_actions()
		_thisthread.sleep(100)
	_endif

	_self.manage_actions()
_endmethod
$

_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.play_image_button_item_selected()
	## play_image_button_item_selected() : _unset
	##
	## starts the animation 

	_local a_thread << .items[:thread]

	_if a_thread _isnt _unset 
	_then
		a_thread.kill()
	_endif

	# when we are preparing for the animation, there is no need to
	# render individual tiles as they become available.  It is
	# faster to render them once they have ALL been received.
	_dynamic !if_wmc_render_all_tiles_together?! << _true
	
	_local me << _self
	_local si << .items[:slider_item]
	
	.items[:thread] << _proc()
				   _import me , si
				   
				   _local i << si.value
				   _local min_value << si.min_value
				   _local max_value << si.max_value
				   
				   _loop
					   si.value_with_notify << i
					   
					   i +<< 1

					   _if i > max_value
					   _then
						   i << min_value-1
					   _endif
					   
				   _endloop
				   
			   _endproc.fork_at(_thisthread.vm_priority - 1)

	_self.manage_actions()
_endmethod
$
_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.manage_actions()
	## manage_actions() : _unset
	##
	## manages GUI widget enabled/disabled values.

	_local a_thread << .items[:thread]

	_local running? << a_thread _isnt _unset _andif
			   a_thread.vm_status _isnt a_thread.status_terminated

	_self.action(:play_image_button_item).enabled? << _not running?
	_self.action(:pause_image_button_item).enabled? << running?
	_self.action(:reset_button_item).enabled? << _not running?
	
_endmethod
$
_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.frames_text_choice_item_selected(frame_value)

	.items[:slider_item].min_value << frame_value.as_number() * -1
	_self.reset()
	_self.slider_item_changed(.items[:slider_item].value)
_endmethod
$
_pragma(classify_level=restricted, topic={map_animator})
_method map_animator.interval_text_choice_item_selected()
	_self.reset()
	_self.slider_item_changed(.items[:slider_item].value)
_endmethod
$









