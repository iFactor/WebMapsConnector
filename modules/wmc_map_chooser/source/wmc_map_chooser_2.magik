#% text_encoding = iso8859_1
##-----------------------------------------------------------------------------------------------
## Web Maps Connector (which shows web maps as layers in Smallworld(TM) Core Spatial Technology)
## Copyright (C) 2017 KUBRA
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http:##www.gnu.org/licenses/>.
##
## You may contact KUBRA at https://kubra.com/contact-us/
##-----------------------------------------------------------------------------------------------

_package user
$
##
##  Auto-generated by Dialog Designer v2.1 : 27/05/2010
##
##  System.user_mame = Graham
##
##  SUPPLIMENTARY code for gui class 'wmc_map_chooser'
##    - add/redefine code here, it will not be auto-modified.

_pragma(classify_level=advanced)
## Indicates whether the map chooser canvas should have a
## vertical scrollbar (Default=False) 
wmc_map_chooser.def_property(:enable_vertical_scrollbar?,
			    :type,          :boolean,
			    :default_value, _false,
			    :readable?,     _true,
			    :writable?,     _true,
			    :description,   "Indicates whether the map chooser canvas should have a vertical scrollbar (Default=False)")
$
_pragma(classify_level=advanced)
## Indicates whether the map chooser canvas should have a
## horizontal scrollbar (Default=False) 
wmc_map_chooser.def_property(:enable_horizontal_scrollbar?,
			    :type,          :boolean,
			    :default_value, _false,
			    :readable?,     _true,
			    :writable?,     _true,
			    :description,   "Indicates whether the map chooser canvas should have a horizontal scrollbar (Default=False)")
$
_pragma(classify_level=basic, usage={redefinable})
## modify this shared constant to configure which tab in the
## Web Map Chooser is initially chosen at GUI activation time. 
wmc_map_chooser.define_shared_constant(:INITIAL_TAB_METHOD_NAME,
	                               :large_icons|()|,
	                               #:small_icons|()|,
				       #:show_map_list|()|,
				       _false)
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
wmc_map_chooser.define_shared_variable(:map_layers,property_list.new(),:public)
$
_pragma(classify_level=restricted, topic={wmc_map_chooser})
wmc_map_chooser.define_shared_variable(:transparent_map_layers,property_list.new(),:public)
$
_pragma(classify_level=restricted, topic={wmc_map_chooser})
wmc_map_chooser.define_shared_variable(:legend_map_layers,property_list.new(),:public)
$
_pragma(classify_level=restricted, topic={wmc_map_chooser})
wmc_map_chooser.define_shared_variable(:labelled_icon_bbs,
	property_list.new_with(:large,pixel_bounding_box.new(0,0,160,100),
			       :small,pixel_bounding_box.new(0,0,150,36)),:public)
$
_pragma(classify_level=restricted, topic={wmc_map_chooser})
wmc_map_chooser.define_shared_variable(:icon_bbs,
	property_list.new_with(:large,pixel_bounding_box.new(-3,-3,135,62),
			       :small,pixel_bounding_box.new(-1,-1,162,33)),:public)
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
wmc_map_chooser.define_shared_constant(:custom_layers,{:|custom-uservoice|},:public)
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.post_activation(_gather args)
	##
	##  Auto-generated by Dialog Designer v2.1 : 27/05/2010

	_if .items _is _unset 
	_then
		_return 
	_endif
	
	.items[:canvas].has_vertical_scrollbar? << _self.enable_vertical_scrollbar?
	.items[:canvas].has_horizontal_scrollbar? << _self.enable_horizontal_scrollbar?
	
	# Reload the map layer definitions whenever the GUI is
	# activated so XML changes are caught immediately.
	_self.init_map_layer_lists()

	_if .items[:map_state] _is _unset 
	_then
		_self.init_icons()
		_self.set_all_maps(_false)
		.items[:select_boxes] << property_list.new()
		
		.items[:current_size] << :large
		_self.set_canvas_agent()
		.items[:ws].value << :canvas
		
		_self.changed(:map_list_aspect,:refresh)
	_endif
	
	.items[:legend_canvas].parent.unmanage()
	.items[:legend_text_bb] << property_list.new()

	_local vds << _self.valid_datasets()
	
	_self.perform(_self.INITIAL_TAB_METHOD_NAME)
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.init_map_layer_lists()
	## 
	## Load the map layers lists from XML

	_local mh << message_handler.new(_self.class_name)
	_dynamic !current_languages!
	_dynamic !current_package!

	_local map_layers_file
	_try
		map_layers_file << smallworld_product.get_data_file("map_layers.xml",_self.module_name)
		_self.map_layers << serial_xml_thing.read_thing_from(map_layers_file)

	_when error
		_self.show_alert(_self.message(:bad_xml_file,map_layers_file))
		_self.map_layers << property_list.new()	
	_endtry


	_local transparent_map_layers_file
	_try
		transparent_map_layers_file << smallworld_product.get_data_file("transparent_map_layers.xml",_self.module_name)
		_self.transparent_map_layers << serial_xml_thing.read_thing_from(transparent_map_layers_file)

	_when error
		_self.show_alert(_self.message(:bad_xml_file,transparent_map_layers_file))
		_self.transparent_map_layers << property_list.new()
	_endtry
	
	_local legend_map_layers_file
	_try
		legend_map_layers_file << smallworld_product.get_data_file("legend_map_layers.xml",_self.module_name)
		_self.legend_map_layers << serial_xml_thing.read_thing_from(legend_map_layers_file)
	_when error
		_self.show_alert(_self.message(:bad_xml_file,legend_map_layers_file))
		_self.legend_map_layers << property_list.new()
	_endtry
	
_endmethod
$


_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.set_canvas_agent()
	## 
	## Set the agent behaviour for the canvas.
	
	a << .items[:canvas].agent
	a.define_redraw( {:|render_icons()|,_unset},_self)	
	a.define_button( :|select_button_released()|,_self,:select)

	a << .items[:legend_canvas].agent
	a.define_redraw( {:|render_legends()|,_unset},_self)	
	a.define_button( :|legend_select_button_released()|,_self,:select)
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.init_icons()
	## 
	## Cache icons for quick rendering.

	.items[:large_icons] << property_list.new()
	.items[:small_icons] << property_list.new()
	.items[:map_legend] << property_list.new()

	_for k _over _self.map_keys()
	_loop
		_try
			.items[:large_icons][k] << smallworld_product.get_raster_image(k.write_string + "-large.bmp",_self.module_name)
		_when resource_not_found_in_module_warning
			.items[:large_icons][k] << smallworld_product.get_raster_image("default-default-large.bmp",_self.module_name)
		_endtry

		
		_try
			.items[:small_icons][k] << smallworld_product.get_raster_image(k.write_string + "-small.bmp",_self.module_name)
		_when resource_not_found_in_module_warning
			.items[:small_icons][k] << smallworld_product.get_raster_image("default-default-small.bmp",_self.module_name)
		_endtry

		
		_try
			.items[:map_legend][k] << smallworld_product.get_raster_image(k.write_string + "-legend.bmp",_self.module_name)
			
		_when resource_not_found_in_module_warning
			# do nothing
		_endtry
	_endloop

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.valid_datasets()
	## 
	## Return a list of datasets the current session has access to.
	
	_if .items[:valid_datasets] _is _unset 
	_then
		_try _with cond
			.items[:valid_datasets] << if_ve_acp.get_valid_vendor_datasets()

		_when ve_current_user_not_sw_auth_validated
			.items[:valid_datasets] << rope.new()
			write(cond.report_string)
			
		_when error
			.items[:valid_datasets] << rope.new()

			write(cond.report_string)
			!traceback!()
		_endtry

		# once we have the list of valid datasets from if_ve_acp, we
		# also append the list with all the currently open datasets.
		# This way a customer can configure WMC Map Chooser to also
		# include their own collections.

		_for ds _over gis_program_manager.cached_datasets()
		_loop
			_if _not .items[:valid_datasets].includes?(ds.name)
			_then
				.items[:valid_datasets].add_last(ds.name)
			_endif
		_endloop
		
	_endif

	>> .items[:valid_datasets]
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_iter _method wmc_map_chooser.map_keys()
	## 
	## Return the list of map keys that are valid for this
	## session.  

	_local valid_datasets << _self.valid_datasets()

	_for ds,maps _over _self.map_layers.fast_keys_and_elements()
	_loop
		_if valid_datasets.includes?(ds)
		_then
			_for m _over maps.fast_elements()
			_loop
				_loopbody(ds+%-+m)
			_endloop
		_endif
		
	_endloop

	# Add custom layers to the bottom of the list
	_for k _over _self.custom_layers.fast_elements() _loop _loopbody(k) _endloop


_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_iter _method wmc_map_chooser.transparent_map_keys()
	## 
	## Return the list of map keys that are transparent and can be
	## viewed with other layers.

	_for ds,maps _over _self.transparent_map_layers.fast_keys_and_elements()
	_loop
		_for m _over maps.fast_elements()
		_loop
			_loopbody(ds+%-+m)
		_endloop
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_iter _method wmc_map_chooser.legend_map_keys()
	## 
	## Return the list of map keys that have a legend.

	_for ds,maps _over _self.legend_map_layers.fast_keys_and_elements()
	_loop
		_for m _over maps.fast_elements()
		_loop
			_loopbody(ds+%-+m)
		_endloop
	_endloop
_endmethod
$



_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.set_all_maps(val)
	## 
	## Set all the map toggles to VAL.
	
	.items[:map_state] << property_list.new()
	
	_for k _over _self.map_keys()
	_loop
		.items[:map_state][k] << val
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.render_icons()
	## 
	## Render the icons onto the canvas.

	size << .items[:current_size].default(:large)
	canv << .items[:canvas]

	labelled_icon_bb << _self.labelled_icon_bbs[size]
	icon_bb << _self.icon_bbs[size]
	ls << line_style.new(colour.called(:red),2)
	lsw << line_style.new(colour.called(:white),2)

	x << 10
	y << 10
	wbb << canv.bounds

	.items[:select_boxes].empty()

	_for k _over _self.map_keys()
	_loop
		_if (r << .items[size + :_icons][k]) _isnt _unset 
		_then
			s << sector.new_with_xy_vector({x+icon_bb.xmin,y+icon_bb.ymin,
							x+icon_bb.xmax,y+icon_bb.ymin,
							x+icon_bb.xmax,y+icon_bb.ymax,
							x+icon_bb.xmin,y+icon_bb.ymax,
							x+icon_bb.xmin,y+icon_bb.ymin})
			.items[:select_boxes][k] << s.bounds

			# Draw selection box as needed.
			_if .items[:map_state][k].default(_true)
			_then
				s.sectors.draw_on(canv,ls)
			_else
				s.sectors.draw_on(canv,lsw)
			_endif

			# Render icon
			canv.render_raster(r,x,y,_false)

			# Figure Text-xy and update xy as needed.
			_if size _is :large
			_then
				(rw,rh) << r.size()
				
				text_x << x + 5
				text_y << y + rh + 20

				_if (x +<< labelled_icon_bb.width) > wbb.width - labelled_icon_bb.width
				_then
					x << 10
					y +<< rh + 38
				_endif
			_else
				text_x << x + 40
				text_y << y + 20

				_if (y +<< labelled_icon_bb.height) > wbb.height - labelled_icon_bb.height
				_then
					y << 10
					x +<< labelled_icon_bb.width + 20
				_endif
			_endif

			# Label the icon
			ts << _if _self.opaque_map?(k)
			      _then
				      >> text_style.new_with_properties(:colour,colour.called(:black))
			      _else
				      >> text_style.new_with_properties(:colour,colour.called(:blue))
			      _endif

			canv.draw_text(ts,text_x,text_y,_self.message(k))
		_endif
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.switch_to_icon()
	## 
	## Prepare the data for an icon rendering.
	_self.update_map_states()
	_self.validate_map_states()
	.items[:canvas].clear()	
	.items[:ws].value << :canvas
	_self.render_icons()
	_self.show_legend()
	_self.changed(:map_list_aspect,:refresh)
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.large_icons()
	.items[:current_size] << :large
	_self.switch_to_icon()
_endmethod
$
_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.small_icons()
	.items[:current_size] << :small
	.items[:canvas].vertical_position << 0
	_self.switch_to_icon()
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.show_map_list()
	.items[:ws].value << :list
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.validate_map_states()
	## 
	## Make sure that only one opaque tile is selected.  Any number
	## of 'transparent' tile sets can be selected.

	opaque_on? << _false
	_for k _over _self.map_keys()
	_loop
		_if .items[:map_state][k] _andif _self.opaque_map?(k)
		_then
			_if opaque_on?
			_then
				.items[:map_state][k] << _false
			_else
				opaque_on? << _true 
			_endif
		_endif
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.opaque_map?(map_key)
	## 
	## Return TRUE if the map keyed by MAP_KEY is NOT transparent.

	_for k _over _self.transparent_map_keys()
	_loop
		_if map_key _is k
		_then
			_return _false 
		_endif
	_endloop

	>> _true 
_endmethod
$


_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.select_button_released(x,y,c)
	## 
	## React to the mouse select button release ...  if a map was
	## selected then update the map selection.   Only one opaque
	## map map be selected at once.  Any number of 'transparent'
	## maps can be selected.
	
	found? << _false 
	_for k,fp _over .items[:select_boxes].fast_keys_and_elements()
	_loop
		# Check to see if the selection was made within a map hotspot.
		_if fp.xmin < x _andif
		    fp.xmax > x _andif
		    fp.ymin < y _andif
		    fp.ymax > y
		_then
			# Handle custom layers (like 'feedback') separately.
			_if _self.custom_layers.includes?(k) _then _return _self.custom_layer_selected(k) _endif
			
			# Toggle the state of the map.
			.items[:map_state][k] << _not .items[:map_state][k]
			found? << _true

			_self.show_legend(k)
			
			# If an opaque map was selected, de-select any other opaque map.
			_if .items[:map_state][k] _andif _self.opaque_map?(k)
			_then
				_for ak _over _self.map_keys()
				_loop
					_if ak _isnt k _andif _self.opaque_map?(ak)
					_then
						.items[:map_state][ak] << _false 
					_endif
				_endloop
			_endif
			
			_leave 
		_endif
	_endloop

	# If a map was selected then re-render the icons and refresh
	# the map list so it is in synch.
	_if found?
	_then
		_self.render_icons()
		_self.changed(:map_list_aspect,:refresh)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.custom_layer_selected(k)
	## 
	## Do something special ... the user just mouse-clicked the K
	## dataset area of the canvas.
	
	_if k _is :|custom-uservoice|
	_then
		# Launch the WebMapConnector feedback site.
		system.do_command(write_string("start http://ifactor.uservoice.com/forums/61547-web-maps-connector"))
	_endif
_endmethod
$


_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.show_legend(_optional a_map_key)
	## 
	## Update the legend panel since A_MAP_KEY map has changed
	## state.  The legend panel is shown if any of the currently
	## selected maps has a legend, otherwise it is hidden.

	show? << _false 
	_for k _over _self.map_keys()
	_loop
		_if .items[:map_state][k] _andif .items[:map_legend][k] _isnt _unset 
		_then
			show? << _true
			_leave 
		_endif
	_endloop

	_if show?
	_then
		.items[:legend_canvas].parent.manage()
		_self.render_legends(a_map_key)
	_else 
		.items[:legend_canvas].parent.unmanage()
	_endif

_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.render_legends(a_map_key)
	## 
	## Render the legends.  A_MAP_KEY map has changed state so
	## either select it or the first other map legend shown.

	x << 10
	y << 16
	dx << 100
	ts << text_style.new_with_properties(:colour,colour.called(:blue))
	c << .items[:legend_canvas]

	.items[:legend_canvas].clear()
	.items[:legend_text_bb].empty()
	
	_for k _over _self.legend_map_keys()
	_loop
		_if .items[:map_state][k].default(_false)
		_then
			c.draw_text(ts,x,y,_self.message(k))
			.items[:legend_text_bb][k] << pixel_bounding_box.new(x-2,y-12,x+80,y+2)
			x +<< dx

			first << first.default(k)
		_endif
	_endloop

	# Now select one, use A_MAP_KEY if it is a visible map
	_if .items[:map_state][a_map_key].default(_false) _andif
	    .items[:map_legend][a_map_key] _isnt _unset 
	_then
		_self.select_legend(a_map_key)
	_else
		_self.select_legend(first)
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.select_legend(a_map_key)
	## 
	## Show the legend keyed by A_MAP_KEY.

	_if a_map_key _is _unset 
	_then
		_return 
	_endif

	ls << line_style.new(colour.called(:red),2)
	s << .items[:legend_text_bb][a_map_key]
	c << .items[:legend_canvas]
	
	s.sectors.draw_on(c,ls)
	r << .items[:map_legend][a_map_key]
	c.render_raster(r,10,30,_false)
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.legend_select_button_released(x,y)
	## 
	## React to the legend graphic being clicked by switching to
	## the selected legend.
	
	_for k,bb _over .items[:legend_text_bb].fast_keys_and_elements()
	_loop
		_if x < bb.xmax _andif x > bb.xmin _andif
		    y < bb.ymax _andif y > bb.ymin
		_then
			_self.show_legend(k)
		_endif
	_endloop
_endmethod
$


_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.map_list_aspect
	## 
	## Return the list of data tile sets.

	_if .items[:map_state] _is _unset 
	_then
		_return {}
	_endif

	map_list << rope.new()
	size << .items[:current_size].default(:large)

	_for k _over _self.map_keys()
	_loop
		_if _self.custom_layers.includes?(k) _then _continue _endif
		
		_if (r << .items[size + :_icons][k]) _isnt _unset 
		_then
			sp << k.write_string.split_by(%-)
			#source << sp[1].split_by(%_).first.capitalise
			#tiles  << sp[2].substitute_character(%_,% ).capitalise
			source << message_handler.new(sp[1].as_symbol()).human_string(:external_name)
			tiles << message_handler.new(sp[2].as_symbol()).human_string(:self)
			v << {.items[:map_state][k],source,tiles}

			ds << display_tree.new(k,v)

			_if _self.opaque_map?(k)
			_then 
				ds.styled_string << {:toggle,1,:tab,:value,2,:tab,:value,3}
			_else
				ds.styled_string << {:toggle,1,:tab,:blue,:value,2,:tab,:blue,:value,3}
			_endif 
			
			map_list.add_last(ds)
		_endif 		
	_endloop

	>> map_list
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.update_map_states()
	## 
	## Update the stored map states based on the list toggles.

	_for d _over .items[:map_list].tree_manager.data.elements()
	_loop
		.items[:map_state][d.key] << d.value[1]
	_endloop
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.clear_selection()
	## 
	## De-select all maps.
	
	_self.set_all_maps(_false)
	_self.changed(:map_list_aspect,:refresh)
	_self.render_icons()
	.items[:legend_canvas].parent.unmanage()
_endmethod
$


_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.apply_maps()
	## 
	## Send the state of each map across the application's databus.

	_self.update_map_states()
	_self.validate_map_states()
	_self.show_legend()
	_self.changed(:map_list_aspect,:refresh)
	
	map_states << rope.new()
	_for on? _over {_true,_false}.fast_elements()
	_loop
		_for d _over .items[:map_list].tree_manager.data.elements()
		_loop
			_if d.value[1] _is on? _then map_states.add({d.value[1],d.key}) _endif 
		_endloop
	_endloop

	_self.databus_make_data_available(:wmc_map_states,map_states)
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.databus_make_data_available(type,data)
	## 
	## Helper ... put data onto the applications databus.

	_if .items _isnt _unset _andif
	    .items[:application] _isnt _unset
	_then
		.items[:application].databus.make_data_available(type,data)
	_else
		_self.application.databus.make_data_available(type,data)
	_endif 
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.hide_map_chooser()
	## 
	## Hide SELF.
	
	_self.application.plugin(:wmc_map_chooser_plugin).action(:show_hide_map_chooser).value << _false	
_endmethod
$
_pragma(classify_level=basic, topic={wmc_map_chooser})
_method wmc_map_chooser.custom_build_gui()
	
	
_endmethod
$

_pragma(classify_level=restricted, topic={wmc_map_chooser})
_method wmc_map_chooser.change_opacity(opacity)
	##
	##  Auto-generated by Dialog Designer v2.7 : 06/02/2014


	_global sw:g_opacity_scale

	sw:g_opacity_scale << opacity

	_self.application.ace.set_user_data(:wmc_opacity_scale,opacity)

	_self.apply_maps()
_endmethod
$

